<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastEngine: fge::net::rules::ChainedArguments&lt; TValue &gt; Struct Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FastEngine<span id="projectnumber">&#160;0.9.4</span>
   </div>
   <div id="projectbrief">A multiplayer oriented 2D engine made with Vulkan.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fge</b></li><li class="navelem"><b>net</b></li><li class="navelem"><b>rules</b></li><li class="navelem"><a href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d3/dcd/classfge_1_1net_1_1rules_1_1ChainedArguments-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fge::net::rules::ChainedArguments&lt; TValue &gt; Struct Template Reference<div class="ingroups"><a class="el" href="../../df/d38/group__networkRules.html">Network rules</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This is a wrapper around a <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> and a value for safe extraction.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/dc1/network__manager_8hpp_source.html">network_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6c1295867295fd2cb7686c6e3c5ad05" id="r_ae6c1295867295fd2cb7686c6e3c5ad05"><td class="memItemLeft" align="right" valign="top"><a id="ae6c1295867295fd2cb7686c6e3c5ad05" name="ae6c1295867295fd2cb7686c6e3c5ad05"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> const &amp;pck, TValue *existingValue=nullptr)</td></tr>
<tr class="memitem:abf1923b321ca62b16985d4a276f6bfa0" id="r_abf1923b321ca62b16985d4a276f6bfa0"><td class="memItemLeft" align="right" valign="top"><a id="abf1923b321ca62b16985d4a276f6bfa0" name="abf1923b321ca62b16985d4a276f6bfa0"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> const &amp;pck, <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err, TValue *existingValue=nullptr)</td></tr>
<tr class="memitem:ab88a5897cf436ee6c61cef9ea23561ca" id="r_ab88a5897cf436ee6c61cef9ea23561ca"><td class="memItemLeft" align="right" valign="top"><a id="ab88a5897cf436ee6c61cef9ea23561ca" name="ab88a5897cf436ee6c61cef9ea23561ca"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> const &amp;r)=default</td></tr>
<tr class="memitem:a4638855113e3d8e45682621d5299e82b" id="r_a4638855113e3d8e45682621d5299e82b"><td class="memItemLeft" align="right" valign="top"><a id="a4638855113e3d8e45682621d5299e82b" name="a4638855113e3d8e45682621d5299e82b"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&amp;r) noexcept=default</td></tr>
<tr class="memitem:a41dd4a210c4fedcedf55270f675bb218" id="r_a41dd4a210c4fedcedf55270f675bb218"><td class="memItemLeft" align="right" valign="top"><a id="a41dd4a210c4fedcedf55270f675bb218" name="a41dd4a210c4fedcedf55270f675bb218"></a>
constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> const &amp;r)=default</td></tr>
<tr class="memitem:ad571dcadf3979ec62649692335dc20f5" id="r_ad571dcadf3979ec62649692335dc20f5"><td class="memItemLeft" align="right" valign="top"><a id="ad571dcadf3979ec62649692335dc20f5" name="ad571dcadf3979ec62649692335dc20f5"></a>
constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&amp;r) noexcept=default</td></tr>
<tr class="memitem:a7f901cd11c0e8db5bc1f4139d9e61cd3" id="r_a7f901cd11c0e8db5bc1f4139d9e61cd3"><td class="memItemLeft" align="right" valign="top">constexpr TValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f901cd11c0e8db5bc1f4139d9e61cd3">extract</a> ()</td></tr>
<tr class="memdesc:a7f901cd11c0e8db5bc1f4139d9e61cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and verify the value from the packet.  <br /></td></tr>
<tr class="memitem:a22c5c2f591dee2d52a5b4b126de2d564" id="r_a22c5c2f591dee2d52a5b4b126de2d564"><td class="memTemplParams" colspan="2">template&lt;class TPeek&gt; </td></tr>
<tr class="memitem:a22c5c2f591dee2d52a5b4b126de2d564 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; TPeek &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22c5c2f591dee2d52a5b4b126de2d564">peek</a> ()</td></tr>
<tr class="memdesc:a22c5c2f591dee2d52a5b4b126de2d564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek without changing the read position a copy of value.  <br /></td></tr>
<tr class="memitem:a27f9a2a22e9bb68c7885f00bcd3de75b" id="r_a27f9a2a22e9bb68c7885f00bcd3de75b"><td class="memItemLeft" align="right" valign="top"><a id="a27f9a2a22e9bb68c7885f00bcd3de75b" name="a27f9a2a22e9bb68c7885f00bcd3de75b"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator Packet const &amp;</b> () const</td></tr>
<tr class="memitem:a4d0fee0a23adbfefde8034791be5fe16" id="r_a4d0fee0a23adbfefde8034791be5fe16"><td class="memItemLeft" align="right" valign="top"><a id="a4d0fee0a23adbfefde8034791be5fe16" name="a4d0fee0a23adbfefde8034791be5fe16"></a>
constexpr <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>packet</b> () const</td></tr>
<tr class="memitem:a401597075c6ad773b859538cf65f3145" id="r_a401597075c6ad773b859538cf65f3145"><td class="memItemLeft" align="right" valign="top"><a id="a401597075c6ad773b859538cf65f3145" name="a401597075c6ad773b859538cf65f3145"></a>
constexpr TValue const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> () const</td></tr>
<tr class="memitem:a765bbea1d7eefbf9598b8ce1fdb64773" id="r_a765bbea1d7eefbf9598b8ce1fdb64773"><td class="memItemLeft" align="right" valign="top"><a id="a765bbea1d7eefbf9598b8ce1fdb64773" name="a765bbea1d7eefbf9598b8ce1fdb64773"></a>
constexpr TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> ()</td></tr>
<tr class="memitem:a922ca02c23d4f4a9954f93b5228e60e8" id="r_a922ca02c23d4f4a9954f93b5228e60e8"><td class="memTemplParams" colspan="2">template&lt;class TInvokable&gt; </td></tr>
<tr class="memitem:a922ca02c23d4f4a9954f93b5228e60e8 template"><td class="memItemLeft" align="right" valign="top">constexpr std::invoke_result_t&lt; TInvokable, <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922ca02c23d4f4a9954f93b5228e60e8">and_then</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a922ca02c23d4f4a9954f93b5228e60e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code after a successful extraction.  <br /></td></tr>
<tr class="memitem:a9ad6590d604c04a0c717fddcb4513910" id="r_a9ad6590d604c04a0c717fddcb4513910"><td class="memTemplParams" colspan="2">template&lt;class TInvokable, class TIndex&gt; </td></tr>
<tr class="memitem:a9ad6590d604c04a0c717fddcb4513910 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad6590d604c04a0c717fddcb4513910">and_for_each</a> (TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a9ad6590d604c04a0c717fddcb4513910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="memitem:ac879f0bff430b6f749f906a6ca68cb3f" id="r_ac879f0bff430b6f749f906a6ca68cb3f"><td class="memTemplParams" colspan="2">template&lt;class TInvokable, class TIndex&gt; </td></tr>
<tr class="memitem:ac879f0bff430b6f749f906a6ca68cb3f template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac879f0bff430b6f749f906a6ca68cb3f">and_for_each</a> (TIndex iStart, TIndex iIncrement, TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:ac879f0bff430b6f749f906a6ca68cb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="memitem:a45477024fbdeae1940a3f33235f4e49f" id="r_a45477024fbdeae1940a3f33235f4e49f"><td class="memTemplParams" colspan="2">template&lt;class TInvokable&gt; </td></tr>
<tr class="memitem:a45477024fbdeae1940a3f33235f4e49f template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45477024fbdeae1940a3f33235f4e49f">and_for_each</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a45477024fbdeae1940a3f33235f4e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="memitem:ae277773855b04dd5d3cbfbb4bc481266" id="r_ae277773855b04dd5d3cbfbb4bc481266"><td class="memTemplParams" colspan="2">template&lt;class TInvokable&gt; </td></tr>
<tr class="memitem:ae277773855b04dd5d3cbfbb4bc481266 template"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae277773855b04dd5d3cbfbb4bc481266">on_error</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:ae277773855b04dd5d3cbfbb4bc481266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code after an unsuccessful extraction.  <br /></td></tr>
<tr class="memitem:ae5091a3d52b20851b20949ca08482fbb" id="r_ae5091a3d52b20851b20949ca08482fbb"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5091a3d52b20851b20949ca08482fbb">end</a> ()</td></tr>
<tr class="memdesc:ae5091a3d52b20851b20949ca08482fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the chain by doing a last validity check on the packet.  <br /></td></tr>
<tr class="memitem:a5d70814f10df4d5ecacbd13d9d5318aa" id="r_a5d70814f10df4d5ecacbd13d9d5318aa"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d70814f10df4d5ecacbd13d9d5318aa">final</a> ()</td></tr>
<tr class="memdesc:a5d70814f10df4d5ecacbd13d9d5318aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the chain by doing a last validity check on the packet.  <br /></td></tr>
<tr class="memitem:a578527b41d5896183f3c3da985bf6d42" id="r_a578527b41d5896183f3c3da985bf6d42"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578527b41d5896183f3c3da985bf6d42">skip</a> () const</td></tr>
<tr class="memdesc:a578527b41d5896183f3c3da985bf6d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to "continue" in a <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each()</a> loop without returning an error.  <br /></td></tr>
<tr class="memitem:aa3606ec9b96ed4ad1937506cd9557bc6" id="r_aa3606ec9b96ed4ad1937506cd9557bc6"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3606ec9b96ed4ad1937506cd9557bc6">stop</a> (char const *error, char const *function) const</td></tr>
<tr class="memdesc:aa3606ec9b96ed4ad1937506cd9557bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to "break" in a <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each()</a> loop with a custom error.  <br /></td></tr>
<tr class="memitem:a79ffa90575c65d4ae9cc5fd31b7a859d" id="r_a79ffa90575c65d4ae9cc5fd31b7a859d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ffa90575c65d4ae9cc5fd31b7a859d">apply</a> (TValue &amp;value)</td></tr>
<tr class="memdesc:a79ffa90575c65d4ae9cc5fd31b7a859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the extracted value to the provided reference.  <br /></td></tr>
<tr class="memitem:a42bc31e23e66a4a29bb428ee94cee79d" id="r_a42bc31e23e66a4a29bb428ee94cee79d"><td class="memTemplParams" colspan="2">template&lt;class TInvokable&gt; </td></tr>
<tr class="memitem:a42bc31e23e66a4a29bb428ee94cee79d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42bc31e23e66a4a29bb428ee94cee79d">apply</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a42bc31e23e66a4a29bb428ee94cee79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the extracted value to the provided invokable argument.  <br /></td></tr>
<tr class="memitem:a0de90a10b76876c404edf586cfab486d" id="r_a0de90a10b76876c404edf586cfab486d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de90a10b76876c404edf586cfab486d">setError</a> (<a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err)</td></tr>
<tr class="memdesc:a0de90a10b76876c404edf586cfab486d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error.  <br /></td></tr>
<tr class="memitem:ae5688f654ba08df2dcead1a947844419" id="r_ae5688f654ba08df2dcead1a947844419"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5688f654ba08df2dcead1a947844419">invalidate</a> (<a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err)</td></tr>
<tr class="memdesc:ae5688f654ba08df2dcead1a947844419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the packet and set the error.  <br /></td></tr>
<tr class="memitem:a8e212bdff8eebc8478a9fe23d4ce31ef" id="r_a8e212bdff8eebc8478a9fe23d4ce31ef"><td class="memItemLeft" align="right" valign="top"><a id="a8e212bdff8eebc8478a9fe23d4ce31ef" name="a8e212bdff8eebc8478a9fe23d4ce31ef"></a>
constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>invalidate</b> (char const *error, char const *function)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class TValue&gt;<br />
struct fge::net::rules::ChainedArguments&lt; TValue &gt;</div><p>This is a wrapper around a <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> and a value for safe extraction. </p>
<p>A <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> is the argument for all network extraction rules. The goal is to chain up multiple rules and at the end output an optional error.</p>
<p>When the packet is invalid, the chain will stop and the error will be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>The type of the value that will be extracted </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a9ad6590d604c04a0c717fddcb4513910" name="a9ad6590d604c04a0c717fddcb4513910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad6590d604c04a0c717fddcb4513910">&#9670;&#160;</a></span>and_for_each() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable, class TIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iIncrement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>If the packet is invalid, the chain will stop and the invokable argument will not be called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
    <tr><td class="paramname">TIndex</td><td>The type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iStart</td><td>The starting value of the index </td></tr>
    <tr><td class="paramname">iEnd</td><td>The ending value of the index </td></tr>
    <tr><td class="paramname">iIncrement</td><td>The increment value of the index </td></tr>
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="ac879f0bff430b6f749f906a6ca68cb3f" name="ac879f0bff430b6f749f906a6ca68cb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac879f0bff430b6f749f906a6ca68cb3f">&#9670;&#160;</a></span>and_for_each() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable, class TIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iIncrement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>This is the same as <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each(TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable&amp;&amp; f)</a> but you don't have to provide the end value of the index as it will be got from the last chain result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
    <tr><td class="paramname">TIndex</td><td>The type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iStart</td><td>The starting value of the index </td></tr>
    <tr><td class="paramname">iIncrement</td><td>The increment value of the index </td></tr>
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a45477024fbdeae1940a3f33235f4e49f" name="a45477024fbdeae1940a3f33235f4e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45477024fbdeae1940a3f33235f4e49f">&#9670;&#160;</a></span>and_for_each() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>This is the same as <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each(TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable&amp;&amp; f)</a> but you don't have to provide any index arguments as the end value of the index as it will be got from the last chain result and the start is 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a922ca02c23d4f4a9954f93b5228e60e8" name="a922ca02c23d4f4a9954f93b5228e60e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922ca02c23d4f4a9954f93b5228e60e8">&#9670;&#160;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::invoke_result_t&lt; TInvokable, <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code after a successful extraction. </p>
<p>If the packet is invalid, the chain will stop and the invokable argument will not be called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a42bc31e23e66a4a29bb428ee94cee79d" name="a42bc31e23e66a4a29bb428ee94cee79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc31e23e66a4a29bb428ee94cee79d">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the extracted value to the provided invokable argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="a79ffa90575c65d4ae9cc5fd31b7a859d" name="a79ffa90575c65d4ae9cc5fd31b7a859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ffa90575c65d4ae9cc5fd31b7a859d">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the extracted value to the provided reference. </p>
<p>If the packet is invalid, the value will not be applied. When applied, the internal value is (if possible) moved to the provided reference. So value() must not be called after this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference that will be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="ae5091a3d52b20851b20949ca08482fbb" name="ae5091a3d52b20851b20949ca08482fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5091a3d52b20851b20949ca08482fbb">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End the chain by doing a last validity check on the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>An optional error </dd></dl>

</div>
</div>
<a id="a7f901cd11c0e8db5bc1f4139d9e61cd3" name="a7f901cd11c0e8db5bc1f4139d9e61cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f901cd11c0e8db5bc1f4139d9e61cd3">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue * <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::extract </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract and verify the value from the packet. </p>
<p>If the user as provided an existing value, it will be used instead of creating a new one.</p>
<dl class="section return"><dt>Returns</dt><dd>The extracted value or <b>nullptr</b> if the <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> is/become invalid </dd></dl>

</div>
</div>
<a id="a5d70814f10df4d5ecacbd13d9d5318aa" name="a5d70814f10df4d5ecacbd13d9d5318aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d70814f10df4d5ecacbd13d9d5318aa">&#9670;&#160;</a></span>final()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::final </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End the chain by doing a last validity check on the packet. </p>
<p>Also verify the endReached() method on the packet.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional error </dd></dl>

</div>
</div>
<a id="ae5688f654ba08df2dcead1a947844419" name="ae5688f654ba08df2dcead1a947844419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5688f654ba08df2dcead1a947844419">&#9670;&#160;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate the packet and set the error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="ae277773855b04dd5d3cbfbb4bc481266" name="ae277773855b04dd5d3cbfbb4bc481266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae277773855b04dd5d3cbfbb4bc481266">&#9670;&#160;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TInvokable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::on_error </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code after an unsuccessful extraction. </p>
<p>This must be the last method called in the chain as this return an optional error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional error </dd></dl>

</div>
</div>
<a id="a22c5c2f591dee2d52a5b4b126de2d564" name="a22c5c2f591dee2d52a5b4b126de2d564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c5c2f591dee2d52a5b4b126de2d564">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<div class="memtemplate">
template&lt;class TPeek&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TPeek &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::peek </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek without changing the read position a copy of value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPeek</td><td>The type of the value that will be peeked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the peeked value </dd></dl>

</div>
</div>
<a id="a0de90a10b76876c404edf586cfab486d" name="a0de90a10b76876c404edf586cfab486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de90a10b76876c404edf586cfab486d">&#9670;&#160;</a></span>setError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::setError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="a578527b41d5896183f3c3da985bf6d42" name="a578527b41d5896183f3c3da985bf6d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578527b41d5896183f3c3da985bf6d42">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::skip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to "continue" in a <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each()</a> loop without returning an error. </p>
<p>This should be used only inside a <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each()</a> loop.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional error (construct with std::nullopt) </dd></dl>

</div>
</div>
<a id="aa3606ec9b96ed4ad1937506cd9557bc6" name="aa3606ec9b96ed4ad1937506cd9557bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3606ec9b96ed4ad1937506cd9557bc6">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::stop </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to "break" in a <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each()</a> loop with a custom error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error message </td></tr>
    <tr><td class="paramname">function</td><td>The function name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error built with the provided message </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="../../d0/dc1/network__manager_8hpp_source.html">network_manager.hpp</a></li>
<li><a class="el" href="../../d7/dbb/network__manager_8inl_source.html">network_manager.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
