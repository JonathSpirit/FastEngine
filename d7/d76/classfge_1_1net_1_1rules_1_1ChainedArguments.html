<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastEngine: fge::net::rules::ChainedArguments&lt; TValue &gt; Struct Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FastEngine<span id="projectnumber">&#160;0.9.3</span>
   </div>
   <div id="projectbrief">A multiplayer oriented 2D engine made with Vulkan.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fge</b></li><li class="navelem"><b>net</b></li><li class="navelem"><b>rules</b></li><li class="navelem"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d3/dcd/classfge_1_1net_1_1rules_1_1ChainedArguments-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fge::net::rules::ChainedArguments&lt; TValue &gt; Struct Template Reference<div class="ingroups"><a class="el" href="../../df/d38/group__networkRules.html">Network rules</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This is a wrapper around a <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> and a value for safe extraction.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/dc1/network__manager_8hpp_source.html">network_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a278b362211118efb66c871ffeed0c79e" id="r_a278b362211118efb66c871ffeed0c79e"><td class="memItemLeft" align="right" valign="top"><a id="a278b362211118efb66c871ffeed0c79e" name="a278b362211118efb66c871ffeed0c79e"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck, TValue *existingValue=nullptr)</td></tr>
<tr class="separator:a278b362211118efb66c871ffeed0c79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17da285b58c19dd354c9a750e49956e" id="r_ac17da285b58c19dd354c9a750e49956e"><td class="memItemLeft" align="right" valign="top"><a id="ac17da285b58c19dd354c9a750e49956e" name="ac17da285b58c19dd354c9a750e49956e"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck, <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err, TValue *existingValue=nullptr)</td></tr>
<tr class="separator:ac17da285b58c19dd354c9a750e49956e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88a5897cf436ee6c61cef9ea23561ca" id="r_ab88a5897cf436ee6c61cef9ea23561ca"><td class="memItemLeft" align="right" valign="top"><a id="ab88a5897cf436ee6c61cef9ea23561ca" name="ab88a5897cf436ee6c61cef9ea23561ca"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> const &amp;r)=default</td></tr>
<tr class="separator:ab88a5897cf436ee6c61cef9ea23561ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4638855113e3d8e45682621d5299e82b" id="r_a4638855113e3d8e45682621d5299e82b"><td class="memItemLeft" align="right" valign="top"><a id="a4638855113e3d8e45682621d5299e82b" name="a4638855113e3d8e45682621d5299e82b"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>ChainedArguments</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&amp;r) noexcept=default</td></tr>
<tr class="separator:a4638855113e3d8e45682621d5299e82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd4a210c4fedcedf55270f675bb218" id="r_a41dd4a210c4fedcedf55270f675bb218"><td class="memItemLeft" align="right" valign="top"><a id="a41dd4a210c4fedcedf55270f675bb218" name="a41dd4a210c4fedcedf55270f675bb218"></a>
constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> const &amp;r)=default</td></tr>
<tr class="separator:a41dd4a210c4fedcedf55270f675bb218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad571dcadf3979ec62649692335dc20f5" id="r_ad571dcadf3979ec62649692335dc20f5"><td class="memItemLeft" align="right" valign="top"><a id="ad571dcadf3979ec62649692335dc20f5" name="ad571dcadf3979ec62649692335dc20f5"></a>
constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a> &amp;&amp;r) noexcept=default</td></tr>
<tr class="separator:ad571dcadf3979ec62649692335dc20f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f901cd11c0e8db5bc1f4139d9e61cd3" id="r_a7f901cd11c0e8db5bc1f4139d9e61cd3"><td class="memItemLeft" align="right" valign="top">constexpr TValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f901cd11c0e8db5bc1f4139d9e61cd3">extract</a> ()</td></tr>
<tr class="memdesc:a7f901cd11c0e8db5bc1f4139d9e61cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and verify the value from the packet.  <br /></td></tr>
<tr class="separator:a7f901cd11c0e8db5bc1f4139d9e61cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c5c2f591dee2d52a5b4b126de2d564" id="r_a22c5c2f591dee2d52a5b4b126de2d564"><td class="memTemplParams" colspan="2">template&lt;class TPeek &gt; </td></tr>
<tr class="memitem:a22c5c2f591dee2d52a5b4b126de2d564"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; TPeek &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22c5c2f591dee2d52a5b4b126de2d564">peek</a> ()</td></tr>
<tr class="memdesc:a22c5c2f591dee2d52a5b4b126de2d564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek without changing the read position a copy of value.  <br /></td></tr>
<tr class="separator:a22c5c2f591dee2d52a5b4b126de2d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea9f5e9828972b77e42d91b37db60da" id="r_a0ea9f5e9828972b77e42d91b37db60da"><td class="memItemLeft" align="right" valign="top"><a id="a0ea9f5e9828972b77e42d91b37db60da" name="a0ea9f5e9828972b77e42d91b37db60da"></a>
constexpr <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>packet</b> () const</td></tr>
<tr class="separator:a0ea9f5e9828972b77e42d91b37db60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401597075c6ad773b859538cf65f3145" id="r_a401597075c6ad773b859538cf65f3145"><td class="memItemLeft" align="right" valign="top"><a id="a401597075c6ad773b859538cf65f3145" name="a401597075c6ad773b859538cf65f3145"></a>
constexpr TValue const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> () const</td></tr>
<tr class="separator:a401597075c6ad773b859538cf65f3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765bbea1d7eefbf9598b8ce1fdb64773" id="r_a765bbea1d7eefbf9598b8ce1fdb64773"><td class="memItemLeft" align="right" valign="top"><a id="a765bbea1d7eefbf9598b8ce1fdb64773" name="a765bbea1d7eefbf9598b8ce1fdb64773"></a>
constexpr TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> ()</td></tr>
<tr class="separator:a765bbea1d7eefbf9598b8ce1fdb64773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922ca02c23d4f4a9954f93b5228e60e8" id="r_a922ca02c23d4f4a9954f93b5228e60e8"><td class="memTemplParams" colspan="2">template&lt;class TInvokable &gt; </td></tr>
<tr class="memitem:a922ca02c23d4f4a9954f93b5228e60e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::invoke_result_t&lt; TInvokable, <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a922ca02c23d4f4a9954f93b5228e60e8">and_then</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a922ca02c23d4f4a9954f93b5228e60e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code after a successful extraction.  <br /></td></tr>
<tr class="separator:a922ca02c23d4f4a9954f93b5228e60e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad6590d604c04a0c717fddcb4513910" id="r_a9ad6590d604c04a0c717fddcb4513910"><td class="memTemplParams" colspan="2">template&lt;class TInvokable , class TIndex &gt; </td></tr>
<tr class="memitem:a9ad6590d604c04a0c717fddcb4513910"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ad6590d604c04a0c717fddcb4513910">and_for_each</a> (TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a9ad6590d604c04a0c717fddcb4513910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="separator:a9ad6590d604c04a0c717fddcb4513910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac879f0bff430b6f749f906a6ca68cb3f" id="r_ac879f0bff430b6f749f906a6ca68cb3f"><td class="memTemplParams" colspan="2">template&lt;class TInvokable , class TIndex &gt; </td></tr>
<tr class="memitem:ac879f0bff430b6f749f906a6ca68cb3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac879f0bff430b6f749f906a6ca68cb3f">and_for_each</a> (TIndex iStart, TIndex iIncrement, TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:ac879f0bff430b6f749f906a6ca68cb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="separator:ac879f0bff430b6f749f906a6ca68cb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45477024fbdeae1940a3f33235f4e49f" id="r_a45477024fbdeae1940a3f33235f4e49f"><td class="memTemplParams" colspan="2">template&lt;class TInvokable &gt; </td></tr>
<tr class="memitem:a45477024fbdeae1940a3f33235f4e49f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45477024fbdeae1940a3f33235f4e49f">and_for_each</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a45477024fbdeae1940a3f33235f4e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code in a for loop after a successful extraction.  <br /></td></tr>
<tr class="separator:a45477024fbdeae1940a3f33235f4e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae277773855b04dd5d3cbfbb4bc481266" id="r_ae277773855b04dd5d3cbfbb4bc481266"><td class="memTemplParams" colspan="2">template&lt;class TInvokable &gt; </td></tr>
<tr class="memitem:ae277773855b04dd5d3cbfbb4bc481266"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae277773855b04dd5d3cbfbb4bc481266">on_error</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:ae277773855b04dd5d3cbfbb4bc481266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain up some code after a unsuccessful extraction.  <br /></td></tr>
<tr class="separator:ae277773855b04dd5d3cbfbb4bc481266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5091a3d52b20851b20949ca08482fbb" id="r_ae5091a3d52b20851b20949ca08482fbb"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5091a3d52b20851b20949ca08482fbb">end</a> ()</td></tr>
<tr class="memdesc:ae5091a3d52b20851b20949ca08482fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the chain by doing a last validity check on the packet.  <br /></td></tr>
<tr class="separator:ae5091a3d52b20851b20949ca08482fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4070f27618e804d033dfe7875e4a365" id="r_aa4070f27618e804d033dfe7875e4a365"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4070f27618e804d033dfe7875e4a365">end</a> (std::nullopt_t nullopt) const</td></tr>
<tr class="memdesc:aa4070f27618e804d033dfe7875e4a365"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the chain without returning an error.  <br /></td></tr>
<tr class="separator:aa4070f27618e804d033dfe7875e4a365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d32c4ee6cf63c85523c43d1de7f9c4a" id="r_a4d32c4ee6cf63c85523c43d1de7f9c4a"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d32c4ee6cf63c85523c43d1de7f9c4a">end</a> (<a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err) const</td></tr>
<tr class="memdesc:a4d32c4ee6cf63c85523c43d1de7f9c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the chain by returning a custom error$.  <br /></td></tr>
<tr class="separator:a4d32c4ee6cf63c85523c43d1de7f9c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ffa90575c65d4ae9cc5fd31b7a859d" id="r_a79ffa90575c65d4ae9cc5fd31b7a859d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ffa90575c65d4ae9cc5fd31b7a859d">apply</a> (TValue &amp;value)</td></tr>
<tr class="memdesc:a79ffa90575c65d4ae9cc5fd31b7a859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the extracted value to the provided reference.  <br /></td></tr>
<tr class="separator:a79ffa90575c65d4ae9cc5fd31b7a859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc31e23e66a4a29bb428ee94cee79d" id="r_a42bc31e23e66a4a29bb428ee94cee79d"><td class="memTemplParams" colspan="2">template&lt;class TInvokable &gt; </td></tr>
<tr class="memitem:a42bc31e23e66a4a29bb428ee94cee79d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42bc31e23e66a4a29bb428ee94cee79d">apply</a> (TInvokable &amp;&amp;f)</td></tr>
<tr class="memdesc:a42bc31e23e66a4a29bb428ee94cee79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the extracted value to the provided invokable argument.  <br /></td></tr>
<tr class="separator:a42bc31e23e66a4a29bb428ee94cee79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2463a3cd0fb7644ac5776077610aa94e" id="r_a2463a3cd0fb7644ac5776077610aa94e"><td class="memTemplParams" colspan="2">template&lt;class TNewValue &gt; </td></tr>
<tr class="memitem:a2463a3cd0fb7644ac5776077610aa94e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TNewValue &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2463a3cd0fb7644ac5776077610aa94e">newChain</a> (TNewValue *existingValue=nullptr)</td></tr>
<tr class="memdesc:a2463a3cd0fb7644ac5776077610aa94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new chain with a different value type.  <br /></td></tr>
<tr class="separator:a2463a3cd0fb7644ac5776077610aa94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb647f2432d2486fb0241f92c414a9d" id="r_a9eb647f2432d2486fb0241f92c414a9d"><td class="memTemplParams" colspan="2">template&lt;class TNewValue &gt; </td></tr>
<tr class="memitem:a9eb647f2432d2486fb0241f92c414a9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TNewValue &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9eb647f2432d2486fb0241f92c414a9d">newChain</a> (TNewValue *existingValue=nullptr) const</td></tr>
<tr class="memdesc:a9eb647f2432d2486fb0241f92c414a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new chain with a different value type.  <br /></td></tr>
<tr class="separator:a9eb647f2432d2486fb0241f92c414a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de90a10b76876c404edf586cfab486d" id="r_a0de90a10b76876c404edf586cfab486d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de90a10b76876c404edf586cfab486d">setError</a> (<a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err)</td></tr>
<tr class="memdesc:a0de90a10b76876c404edf586cfab486d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error.  <br /></td></tr>
<tr class="separator:a0de90a10b76876c404edf586cfab486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5688f654ba08df2dcead1a947844419" id="r_ae5688f654ba08df2dcead1a947844419"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5688f654ba08df2dcead1a947844419">invalidate</a> (<a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;err)</td></tr>
<tr class="memdesc:ae5688f654ba08df2dcead1a947844419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the packet and set the error.  <br /></td></tr>
<tr class="separator:ae5688f654ba08df2dcead1a947844419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class TValue&gt;<br />
struct fge::net::rules::ChainedArguments&lt; TValue &gt;</div><p>This is a wrapper around a <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> and a value for safe extraction. </p>
<p>A <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> is the argument for all network extraction rules. The goal is to chain up multiple rules and at the end output an optional error.</p>
<p>When the packet is invalid, the chain will stop and the error will be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>The type of the value that will be extracted </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ad6590d604c04a0c717fddcb4513910" name="a9ad6590d604c04a0c717fddcb4513910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad6590d604c04a0c717fddcb4513910">&#9670;&#160;</a></span>and_for_each() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable , class TIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iIncrement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>If the packet is invalid, the chain will stop and the invokable argument will not be called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
    <tr><td class="paramname">TIndex</td><td>The type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iStart</td><td>The starting value of the index </td></tr>
    <tr><td class="paramname">iEnd</td><td>The ending value of the index </td></tr>
    <tr><td class="paramname">iIncrement</td><td>The increment value of the index </td></tr>
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="ac879f0bff430b6f749f906a6ca68cb3f" name="ac879f0bff430b6f749f906a6ca68cb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac879f0bff430b6f749f906a6ca68cb3f">&#9670;&#160;</a></span>and_for_each() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable , class TIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>iIncrement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>This is the same as <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each(TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable&amp;&amp; f)</a> but you don't have to provide the end value of the index as it will be got from the last chain result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
    <tr><td class="paramname">TIndex</td><td>The type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iStart</td><td>The starting value of the index </td></tr>
    <tr><td class="paramname">iIncrement</td><td>The increment value of the index </td></tr>
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a45477024fbdeae1940a3f33235f4e49f" name="a45477024fbdeae1940a3f33235f4e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45477024fbdeae1940a3f33235f4e49f">&#9670;&#160;</a></span>and_for_each() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_for_each </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code in a for loop after a successful extraction. </p>
<p>This is the same as <a class="el" href="#a9ad6590d604c04a0c717fddcb4513910" title="Chain up some code in a for loop after a successful extraction.">and_for_each(TIndex iStart, TIndex iEnd, TIndex iIncrement, TInvokable&amp;&amp; f)</a> but you don't have to provide any index arguments as the end value of the index as it will be got from the last chain result and the start is 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a922ca02c23d4f4a9954f93b5228e60e8" name="a922ca02c23d4f4a9954f93b5228e60e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922ca02c23d4f4a9954f93b5228e60e8">&#9670;&#160;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::invoke_result_t&lt; TInvokable, <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code after a successful extraction. </p>
<p>If the packet is invalid, the chain will stop and the invokable argument will not be called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> or a new one with a different value type </dd></dl>

</div>
</div>
<a id="a42bc31e23e66a4a29bb428ee94cee79d" name="a42bc31e23e66a4a29bb428ee94cee79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc31e23e66a4a29bb428ee94cee79d">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the extracted value to the provided invokable argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="a79ffa90575c65d4ae9cc5fd31b7a859d" name="a79ffa90575c65d4ae9cc5fd31b7a859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ffa90575c65d4ae9cc5fd31b7a859d">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the extracted value to the provided reference. </p>
<p>If the packet is invalid, the value will not be applied. When applied, the internal value is (if possible) moved to the provided reference. So value() must not be called after this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference that will be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="ae5091a3d52b20851b20949ca08482fbb" name="ae5091a3d52b20851b20949ca08482fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5091a3d52b20851b20949ca08482fbb">&#9670;&#160;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End the chain by doing a last validity check on the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>An optional error </dd></dl>

</div>
</div>
<a id="a4d32c4ee6cf63c85523c43d1de7f9c4a" name="a4d32c4ee6cf63c85523c43d1de7f9c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d32c4ee6cf63c85523c43d1de7f9c4a">&#9670;&#160;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End the chain by returning a custom error$. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional error (construct with err) </dd></dl>

</div>
</div>
<a id="aa4070f27618e804d033dfe7875e4a365" name="aa4070f27618e804d033dfe7875e4a365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4070f27618e804d033dfe7875e4a365">&#9670;&#160;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::end </td>
          <td>(</td>
          <td class="paramtype">std::nullopt_t</td>          <td class="paramname"><span class="paramname"><em>nullopt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End the chain without returning an error. </p>
<p>This is useful when you want to skip in a and_for_each loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nullopt</td><td>A nullopt_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional error (construct with nullopt) </dd></dl>

</div>
</div>
<a id="a7f901cd11c0e8db5bc1f4139d9e61cd3" name="a7f901cd11c0e8db5bc1f4139d9e61cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f901cd11c0e8db5bc1f4139d9e61cd3">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue * <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::extract </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract and verify the value from the packet. </p>
<p>If the user as provided an existing value, it will be used instead of creating a new one.</p>
<dl class="section return"><dt>Returns</dt><dd>The extracted value or <b>nullptr</b> if the <a class="el" href="../../de/d3e/classfge_1_1net_1_1Packet.html">Packet</a> is/become invalid </dd></dl>

</div>
</div>
<a id="ae5688f654ba08df2dcead1a947844419" name="ae5688f654ba08df2dcead1a947844419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5688f654ba08df2dcead1a947844419">&#9670;&#160;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate the packet and set the error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<a id="a2463a3cd0fb7644ac5776077610aa94e" name="a2463a3cd0fb7644ac5776077610aa94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2463a3cd0fb7644ac5776077610aa94e">&#9670;&#160;</a></span>newChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TNewValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TNewValue &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::newChain </td>
          <td>(</td>
          <td class="paramtype">TNewValue *</td>          <td class="paramname"><span class="paramname"><em>existingValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new chain with a different value type. </p>
<p>The packet and the error will be copied/moved to the new chain.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TNewValue</td><td>The type of the new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existingValue</td><td>An optional existing value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> with a different value type </dd></dl>

</div>
</div>
<a id="a9eb647f2432d2486fb0241f92c414a9d" name="a9eb647f2432d2486fb0241f92c414a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb647f2432d2486fb0241f92c414a9d">&#9670;&#160;</a></span>newChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TNewValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TNewValue &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::newChain </td>
          <td>(</td>
          <td class="paramtype">TNewValue *</td>          <td class="paramname"><span class="paramname"><em>existingValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new chain with a different value type. </p>
<p>This const version is generally used in a and_for_each loop. The error isn't forwarded to the new chain.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TNewValue</td><td>The type of the new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existingValue</td><td>An optional existing value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> with a different value type </dd></dl>

</div>
</div>
<a id="ae277773855b04dd5d3cbfbb4bc481266" name="ae277773855b04dd5d3cbfbb4bc481266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae277773855b04dd5d3cbfbb4bc481266">&#9670;&#160;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TInvokable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::on_error </td>
          <td>(</td>
          <td class="paramtype">TInvokable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chain up some code after a unsuccessful extraction. </p>
<p>This must be the last method called in the chain as this return an optional error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInvokable</td><td>The type of the invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invokable argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional error </dd></dl>

</div>
</div>
<a id="a22c5c2f591dee2d52a5b4b126de2d564" name="a22c5c2f591dee2d52a5b4b126de2d564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c5c2f591dee2d52a5b4b126de2d564">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<div class="memtemplate">
template&lt;class TPeek &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; TPeek &gt; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::peek </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek without changing the read position a copy of value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPeek</td><td>The type of the value that will be peeked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the peeked value </dd></dl>

</div>
</div>
<a id="a0de90a10b76876c404edf586cfab486d" name="a0de90a10b76876c404edf586cfab486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de90a10b76876c404edf586cfab486d">&#9670;&#160;</a></span>setError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">ChainedArguments</a>&lt; TValue &gt; &amp; <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html">fge::net::rules::ChainedArguments</a>&lt; TValue &gt;::setError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d73/structfge_1_1net_1_1Error.html">Error</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the same <a class="el" href="../../d7/d76/classfge_1_1net_1_1rules_1_1ChainedArguments.html" title="This is a wrapper around a Packet and a value for safe extraction.">ChainedArguments</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="../../d0/dc1/network__manager_8hpp_source.html">network_manager.hpp</a></li>
<li><a class="el" href="../../d7/dbb/network__manager_8inl_source.html">network_manager.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
