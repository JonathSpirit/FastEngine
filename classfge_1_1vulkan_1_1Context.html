<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastEngine: fge::vulkan::Context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FastEngine<span id="projectnumber">&#160;0.9.1</span>
   </div>
   <div id="projectbrief">A multiplayer oriented 2D engine made with Vulkan.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fge</b></li><li class="navelem"><b>vulkan</b></li><li class="navelem"><a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classfge_1_1vulkan_1_1Context-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fge::vulkan::Context Class Reference<div class="ingroups"><a class="el" href="group__vulkan.html">Vulkan abstraction</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Vulkan context.  
 <a href="classfge_1_1vulkan_1_1Context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="C__context_8hpp_source.html">C_context.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfge_1_1vulkan_1_1Context_1_1SingleTimeCommand.html">SingleTimeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a52b3945910b6482f1d5e0337b1fa106c" id="r_a52b3945910b6482f1d5e0337b1fa106c"><td class="memItemLeft" align="right" valign="top"><a id="a52b3945910b6482f1d5e0337b1fa106c" name="a52b3945910b6482f1d5e0337b1fa106c"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>SingleTimeCommandTypes</b> { <b>DIRECT_EXECUTION</b>
, <b>INDIRECT_OUTSIDE_RENDER_SCOPE_EXECUTION</b>
 }</td></tr>
<tr class="separator:a52b3945910b6482f1d5e0337b1fa106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80e9da556c01d562135d7e3b8921a177" id="r_a80e9da556c01d562135d7e3b8921a177"><td class="memItemLeft" align="right" valign="top"><a id="a80e9da556c01d562135d7e3b8921a177" name="a80e9da556c01d562135d7e3b8921a177"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> (<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> const &amp;r)=delete</td></tr>
<tr class="separator:a80e9da556c01d562135d7e3b8921a177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a391993caa3488a4c2cce898d6f64bd" id="r_a7a391993caa3488a4c2cce898d6f64bd"><td class="memItemLeft" align="right" valign="top"><a id="a7a391993caa3488a4c2cce898d6f64bd" name="a7a391993caa3488a4c2cce898d6f64bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> (<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> &amp;&amp;r) noexcept=delete</td></tr>
<tr class="separator:a7a391993caa3488a4c2cce898d6f64bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224d32ba61b5bc25e865f82e1026f1bd" id="r_a224d32ba61b5bc25e865f82e1026f1bd"><td class="memItemLeft" align="right" valign="top"><a id="a224d32ba61b5bc25e865f82e1026f1bd" name="a224d32ba61b5bc25e865f82e1026f1bd"></a>
<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> const &amp;r)=delete</td></tr>
<tr class="separator:a224d32ba61b5bc25e865f82e1026f1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79e8e71355d99de7e32bbe0ce8d4f23" id="r_ac79e8e71355d99de7e32bbe0ce8d4f23"><td class="memItemLeft" align="right" valign="top"><a id="ac79e8e71355d99de7e32bbe0ce8d4f23" name="ac79e8e71355d99de7e32bbe0ce8d4f23"></a>
<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classfge_1_1vulkan_1_1Context.html">Context</a> &amp;&amp;r) noexcept=delete</td></tr>
<tr class="separator:ac79e8e71355d99de7e32bbe0ce8d4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f76b44b12ac49bfaf745943cf40c5" id="r_a4e1f76b44b12ac49bfaf745943cf40c5"><td class="memItemLeft" align="right" valign="top"><a id="a4e1f76b44b12ac49bfaf745943cf40c5" name="a4e1f76b44b12ac49bfaf745943cf40c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> ()</td></tr>
<tr class="separator:a4e1f76b44b12ac49bfaf745943cf40c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d1d52cece32a29da99c64bfb67026" id="r_a376d1d52cece32a29da99c64bfb67026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfge_1_1vulkan_1_1Context_1_1SingleTimeCommand.html">SingleTimeCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a376d1d52cece32a29da99c64bfb67026">beginSingleTimeCommands</a> (SingleTimeCommandTypes type) const</td></tr>
<tr class="memdesc:a376d1d52cece32a29da99c64bfb67026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a single time command.  <br /></td></tr>
<tr class="separator:a376d1d52cece32a29da99c64bfb67026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f1ce22ec25aa3234ca4a539d09213" id="r_acc4f1ce22ec25aa3234ca4a539d09213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#acc4f1ce22ec25aa3234ca4a539d09213">endSingleTimeCommands</a> (<a class="el" href="structfge_1_1vulkan_1_1Context_1_1SingleTimeCommand.html">SingleTimeCommand</a> command) const</td></tr>
<tr class="memdesc:acc4f1ce22ec25aa3234ca4a539d09213"><td class="mdescLeft">&#160;</td><td class="mdescRight">End a single time command.  <br /></td></tr>
<tr class="separator:acc4f1ce22ec25aa3234ca4a539d09213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fb97ddcb7699cb7eda8acc3dc772c4" id="r_a08fb97ddcb7699cb7eda8acc3dc772c4"><td class="memItemLeft" align="right" valign="top">VkSemaphore&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a08fb97ddcb7699cb7eda8acc3dc772c4">getOutsideRenderScopeSemaphore</a> () const</td></tr>
<tr class="memdesc:a08fb97ddcb7699cb7eda8acc3dc772c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the semaphore that is signaled when the outside render scope command buffer have finished executing.  <br /></td></tr>
<tr class="separator:a08fb97ddcb7699cb7eda8acc3dc772c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa286e856957b06e10b00bcd81fd3c59d" id="r_aa286e856957b06e10b00bcd81fd3c59d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#aa286e856957b06e10b00bcd81fd3c59d">submit</a> () const</td></tr>
<tr class="memdesc:aa286e856957b06e10b00bcd81fd3c59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit <a class="el" href="classfge_1_1vulkan_1_1Context.html" title="Vulkan context.">Context</a> command buffers.  <br /></td></tr>
<tr class="separator:aa286e856957b06e10b00bcd81fd3c59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5151236d85c7135d573532bea41633d6" id="r_a5151236d85c7135d573532bea41633d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a5151236d85c7135d573532bea41633d6">initVulkan</a> (SDL_Window *window)</td></tr>
<tr class="memdesc:a5151236d85c7135d573532bea41633d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Vulkan.  <br /></td></tr>
<tr class="separator:a5151236d85c7135d573532bea41633d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4839c3c2698193424d930eb0b9ef7138" id="r_a4839c3c2698193424d930eb0b9ef7138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a4839c3c2698193424d930eb0b9ef7138">waitIdle</a> ()</td></tr>
<tr class="memdesc:a4839c3c2698193424d930eb0b9ef7138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the device to be idle.  <br /></td></tr>
<tr class="separator:a4839c3c2698193424d930eb0b9ef7138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102d68172ab46ae88e9d17a4389d82e8" id="r_a102d68172ab46ae88e9d17a4389d82e8"><td class="memItemLeft" align="right" valign="top"><a id="a102d68172ab46ae88e9d17a4389d82e8" name="a102d68172ab46ae88e9d17a4389d82e8"></a>
const <a class="el" href="classfge_1_1vulkan_1_1Instance.html">Instance</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstance</b> () const</td></tr>
<tr class="separator:a102d68172ab46ae88e9d17a4389d82e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c5c9fb068304ddfc80d5bf6d1b2d0" id="r_ad07c5c9fb068304ddfc80d5bf6d1b2d0"><td class="memItemLeft" align="right" valign="top"><a id="ad07c5c9fb068304ddfc80d5bf6d1b2d0" name="ad07c5c9fb068304ddfc80d5bf6d1b2d0"></a>
const <a class="el" href="classfge_1_1vulkan_1_1Surface.html">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSurface</b> () const</td></tr>
<tr class="separator:ad07c5c9fb068304ddfc80d5bf6d1b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c9331cabd49bc1e6c866157dc71b04" id="r_a05c9331cabd49bc1e6c866157dc71b04"><td class="memItemLeft" align="right" valign="top"><a id="a05c9331cabd49bc1e6c866157dc71b04" name="a05c9331cabd49bc1e6c866157dc71b04"></a>
const <a class="el" href="classfge_1_1vulkan_1_1LogicalDevice.html">LogicalDevice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLogicalDevice</b> () const</td></tr>
<tr class="separator:a05c9331cabd49bc1e6c866157dc71b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e94568908a1fc1d511e7bc2bf2c0288" id="r_a1e94568908a1fc1d511e7bc2bf2c0288"><td class="memItemLeft" align="right" valign="top"><a id="a1e94568908a1fc1d511e7bc2bf2c0288" name="a1e94568908a1fc1d511e7bc2bf2c0288"></a>
const <a class="el" href="classfge_1_1vulkan_1_1PhysicalDevice.html">PhysicalDevice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getPhysicalDevice</b> () const</td></tr>
<tr class="separator:a1e94568908a1fc1d511e7bc2bf2c0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dbe534fa869f54ec37cb138edccaa3" id="r_ab7dbe534fa869f54ec37cb138edccaa3"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#ab7dbe534fa869f54ec37cb138edccaa3">getGraphicsCommandPool</a> () const</td></tr>
<tr class="memdesc:ab7dbe534fa869f54ec37cb138edccaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a command pool for graphics commands.  <br /></td></tr>
<tr class="separator:ab7dbe534fa869f54ec37cb138edccaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa021e11d8931e917c86670df69006e42" id="r_aa021e11d8931e917c86670df69006e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#aa021e11d8931e917c86670df69006e42">allocateGraphicsCommandBuffers</a> (VkCommandBufferLevel level, VkCommandBuffer commandBuffers[], uint32_t commandBufferCount) const</td></tr>
<tr class="memdesc:aa021e11d8931e917c86670df69006e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate graphics command buffers.  <br /></td></tr>
<tr class="separator:aa021e11d8931e917c86670df69006e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7967b4bcd03d26b3d508442a7ac73878" id="r_a7967b4bcd03d26b3d508442a7ac73878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a7967b4bcd03d26b3d508442a7ac73878">copyBuffer</a> (VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) const</td></tr>
<tr class="memdesc:a7967b4bcd03d26b3d508442a7ac73878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to another.  <br /></td></tr>
<tr class="separator:a7967b4bcd03d26b3d508442a7ac73878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae019452672384d90cdf28ed8b8b7d49a" id="r_ae019452672384d90cdf28ed8b8b7d49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#ae019452672384d90cdf28ed8b8b7d49a">transitionImageLayout</a> (VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout) const</td></tr>
<tr class="memdesc:ae019452672384d90cdf28ed8b8b7d49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an image layout.  <br /></td></tr>
<tr class="separator:ae019452672384d90cdf28ed8b8b7d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685c17fed0e9847827e4c64810ed655b" id="r_a685c17fed0e9847827e4c64810ed655b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a685c17fed0e9847827e4c64810ed655b">copyBufferToImage</a> (VkBuffer buffer, VkImage image, uint32_t width, uint32_t height, int32_t offsetX=0, int32_t offsetY=0) const</td></tr>
<tr class="memdesc:a685c17fed0e9847827e4c64810ed655b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to an image.  <br /></td></tr>
<tr class="separator:a685c17fed0e9847827e4c64810ed655b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d955e22de0ecdf3cc12570a00ff6ef" id="r_a34d955e22de0ecdf3cc12570a00ff6ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a34d955e22de0ecdf3cc12570a00ff6ef">copyImageToBuffer</a> (VkImage image, VkBuffer buffer, uint32_t width, uint32_t height) const</td></tr>
<tr class="memdesc:a34d955e22de0ecdf3cc12570a00ff6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an image to a buffer.  <br /></td></tr>
<tr class="separator:a34d955e22de0ecdf3cc12570a00ff6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216cef6f534b4da7ba524f1e46526b1" id="r_a9216cef6f534b4da7ba524f1e46526b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a9216cef6f534b4da7ba524f1e46526b1">copyImageToImage</a> (VkImage srcImage, VkImage dstImage, uint32_t width, uint32_t height, int32_t offsetX=0, int32_t offsetY=0) const</td></tr>
<tr class="memdesc:a9216cef6f534b4da7ba524f1e46526b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an image to another image.  <br /></td></tr>
<tr class="separator:a9216cef6f534b4da7ba524f1e46526b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b13069b2be507a3b7e893bbf9a5cbc" id="r_af8b13069b2be507a3b7e893bbf9a5cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#af8b13069b2be507a3b7e893bbf9a5cbc">getCacheLayout</a> (std::string_view key) const</td></tr>
<tr class="memdesc:af8b13069b2be507a3b7e893bbf9a5cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve or create a descriptor set layout from a key.  <br /></td></tr>
<tr class="separator:af8b13069b2be507a3b7e893bbf9a5cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0250fa583b569a008469cc427879c1" id="r_a7e0250fa583b569a008469cc427879c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a7e0250fa583b569a008469cc427879c1">getMultiUseDescriptorPool</a> () const</td></tr>
<tr class="memdesc:a7e0250fa583b569a008469cc427879c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "multi-usage" descriptor pool.  <br /></td></tr>
<tr class="separator:a7e0250fa583b569a008469cc427879c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f4594e9357f051596621f0d3373c56" id="r_ad4f4594e9357f051596621f0d3373c56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#ad4f4594e9357f051596621f0d3373c56">getTextureLayout</a> () const</td></tr>
<tr class="memdesc:ad4f4594e9357f051596621f0d3373c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "texture" descriptor set layout.  <br /></td></tr>
<tr class="separator:ad4f4594e9357f051596621f0d3373c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e7803b72427c8f94d35e3b0ef63217" id="r_ad5e7803b72427c8f94d35e3b0ef63217"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#ad5e7803b72427c8f94d35e3b0ef63217">getTransformLayout</a> () const</td></tr>
<tr class="memdesc:ad5e7803b72427c8f94d35e3b0ef63217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "transform" descriptor set layout.  <br /></td></tr>
<tr class="separator:ad5e7803b72427c8f94d35e3b0ef63217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91521a0463be4b0026ea8c1abe17eb96" id="r_a91521a0463be4b0026ea8c1abe17eb96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a91521a0463be4b0026ea8c1abe17eb96">getTextureDescriptorPool</a> () const</td></tr>
<tr class="memdesc:a91521a0463be4b0026ea8c1abe17eb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "texture" descriptor pool.  <br /></td></tr>
<tr class="separator:a91521a0463be4b0026ea8c1abe17eb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820427b1ceef9aaac9cbcf88a90e15a7" id="r_a820427b1ceef9aaac9cbcf88a90e15a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a820427b1ceef9aaac9cbcf88a90e15a7">getTransformDescriptorPool</a> () const</td></tr>
<tr class="memdesc:a820427b1ceef9aaac9cbcf88a90e15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a "transform" descriptor pool.  <br /></td></tr>
<tr class="separator:a820427b1ceef9aaac9cbcf88a90e15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab251473f8bb90da8488a76003ccd0660" id="r_ab251473f8bb90da8488a76003ccd0660"><td class="memItemLeft" align="right" valign="top">VmaAllocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#ab251473f8bb90da8488a76003ccd0660">getAllocator</a> () const</td></tr>
<tr class="memdesc:ab251473f8bb90da8488a76003ccd0660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the VMA (Vulkan Memory Allocator)  <br /></td></tr>
<tr class="separator:ab251473f8bb90da8488a76003ccd0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59403de6ca040b775692b411b433f218" id="r_a59403de6ca040b775692b411b433f218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a59403de6ca040b775692b411b433f218">pushGraphicsCommandBuffer</a> (VkCommandBuffer commandBuffer) const</td></tr>
<tr class="memdesc:a59403de6ca040b775692b411b433f218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a graphics command buffer to a list.  <br /></td></tr>
<tr class="separator:a59403de6ca040b775692b411b433f218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10398b1b0a4c2ee3d8beb13d7a9e6cf0" id="r_a10398b1b0a4c2ee3d8beb13d7a9e6cf0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkCommandBuffer &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a10398b1b0a4c2ee3d8beb13d7a9e6cf0">getGraphicsCommandBuffers</a> () const</td></tr>
<tr class="memdesc:a10398b1b0a4c2ee3d8beb13d7a9e6cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of executable graphics command buffers.  <br /></td></tr>
<tr class="separator:a10398b1b0a4c2ee3d8beb13d7a9e6cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c598145d15a2e574918e63b84357c07" id="r_a9c598145d15a2e574918e63b84357c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a9c598145d15a2e574918e63b84357c07">clearGraphicsCommandBuffers</a> () const</td></tr>
<tr class="memdesc:a9c598145d15a2e574918e63b84357c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of executable graphics command buffers.  <br /></td></tr>
<tr class="separator:a9c598145d15a2e574918e63b84357c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a92724656e6294b1be733cdf931078fa5" id="r_a92724656e6294b1be733cdf931078fa5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a92724656e6294b1be733cdf931078fa5">initVolk</a> ()</td></tr>
<tr class="memdesc:a92724656e6294b1be733cdf931078fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Volk (Vulkan loader)  <br /></td></tr>
<tr class="separator:a92724656e6294b1be733cdf931078fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b48b2ad5cfac87a465e238372d2aa" id="r_a2c2b48b2ad5cfac87a465e238372d2aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a2c2b48b2ad5cfac87a465e238372d2aa">enumerateExtensions</a> ()</td></tr>
<tr class="memdesc:a2c2b48b2ad5cfac87a465e238372d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate to standard output the available extensions.  <br /></td></tr>
<tr class="separator:a2c2b48b2ad5cfac87a465e238372d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39d50bd352ea970756dbb55202d384" id="r_a5a39d50bd352ea970756dbb55202d384"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1vulkan_1_1Context.html#a5a39d50bd352ea970756dbb55202d384">retrieveExtensions</a> ()</td></tr>
<tr class="memdesc:a5a39d50bd352ea970756dbb55202d384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the available extensions.  <br /></td></tr>
<tr class="separator:a5a39d50bd352ea970756dbb55202d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8972655d99ea621257e20879d269d870" id="r_a8972655d99ea621257e20879d269d870"><td class="memItemLeft" align="right" valign="top"><a id="a8972655d99ea621257e20879d269d870" name="a8972655d99ea621257e20879d269d870"></a>
<a class="el" href="classfge_1_1vulkan_1_1GarbageCollector.html">fge::vulkan::GarbageCollector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_garbageCollector</b></td></tr>
<tr class="separator:a8972655d99ea621257e20879d269d870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vulkan context. </p>
<p>This class is the main starting point for Vulkan usage. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa021e11d8931e917c86670df69006e42" name="aa021e11d8931e917c86670df69006e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa021e11d8931e917c86670df69006e42">&#9670;&#160;</a></span>allocateGraphicsCommandBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::allocateGraphicsCommandBuffers </td>
          <td>(</td>
          <td class="paramtype">VkCommandBufferLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>commandBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate graphics command buffers. </p>
<p>This is a shortcut for vkAllocateCommandBuffers with the graphics command pool.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1vulkan_1_1Context.html#ab7dbe534fa869f54ec37cb138edccaa3" title="Retrieve a command pool for graphics commands.">getGraphicsCommandPool()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level of the command buffers (primary or secondary) </td></tr>
    <tr><td class="paramname">commandBuffers</td><td>An array of VkCommandBuffer structures in which the resulting command buffer objects are returned </td></tr>
    <tr><td class="paramname">commandBufferCount</td><td>The number of command buffers to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376d1d52cece32a29da99c64bfb67026" name="a376d1d52cece32a29da99c64bfb67026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376d1d52cece32a29da99c64bfb67026">&#9670;&#160;</a></span>beginSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfge_1_1vulkan_1_1Context_1_1SingleTimeCommand.html">SingleTimeCommand</a> fge::vulkan::Context::beginSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">SingleTimeCommandTypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin a single time command. </p>
<p>This return a command buffer that is ready to be used.</p>
<p>The DIRECT_EXECUTION type is used to execute a command buffer directly, this implies create the buffer, submit the buffer, and waiting for all queue operations to be finished. This is not ideal for performance.</p>
<p>The INDIRECT_OUTSIDE_RENDER_SCOPE_EXECUTION type is used to execute your commands inside a reusable command buffer that is submitted to the graphics queue at the same time as a render command buffer in a RenderScreen. This is ideal for performance like copying staging buffers to device local buffers.</p>
<p>This is also synced with a semaphore that is signaled when the command buffer have finished executing so this assure that every commands are finished before rendering.</p>
<p>All this commands must be executed outside a render scope.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be pared with <a class="el" href="classfge_1_1vulkan_1_1Context.html#acc4f1ce22ec25aa3234ca4a539d09213" title="End a single time command.">endSingleTimeCommands()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The command buffer </dd></dl>

</div>
</div>
<a id="a9c598145d15a2e574918e63b84357c07" name="a9c598145d15a2e574918e63b84357c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c598145d15a2e574918e63b84357c07">&#9670;&#160;</a></span>clearGraphicsCommandBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::clearGraphicsCommandBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the list of executable graphics command buffers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1vulkan_1_1Context.html#a59403de6ca040b775692b411b433f218" title="Push a graphics command buffer to a list.">pushGraphicsCommandBuffer()</a> </dd></dl>

</div>
</div>
<a id="a7967b4bcd03d26b3d508442a7ac73878" name="a7967b4bcd03d26b3d508442a7ac73878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7967b4bcd03d26b3d508442a7ac73878">&#9670;&#160;</a></span>copyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::copyBuffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to another. </p>
<p>Fill a command buffer with a copy command in order to copy a buffer to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>The source buffer </td></tr>
    <tr><td class="paramname">dstBuffer</td><td>The destination buffer </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a685c17fed0e9847827e4c64810ed655b" name="a685c17fed0e9847827e4c64810ed655b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685c17fed0e9847827e4c64810ed655b">&#9670;&#160;</a></span>copyBufferToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::copyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offsetX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offsetY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to an image. </p>
<p>Fill a command buffer with a copy command in order to copy a buffer to an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">image</td><td>The image </td></tr>
    <tr><td class="paramname">width</td><td>Width of the image </td></tr>
    <tr><td class="paramname">height</td><td>Height of the image </td></tr>
    <tr><td class="paramname">offsetX</td><td>An offset on the X axis </td></tr>
    <tr><td class="paramname">offsetY</td><td>An offset on the Y axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34d955e22de0ecdf3cc12570a00ff6ef" name="a34d955e22de0ecdf3cc12570a00ff6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d955e22de0ecdf3cc12570a00ff6ef">&#9670;&#160;</a></span>copyImageToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::copyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an image to a buffer. </p>
<p>Fill a command buffer with a copy command in order to copy an image to a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9216cef6f534b4da7ba524f1e46526b1" name="a9216cef6f534b4da7ba524f1e46526b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9216cef6f534b4da7ba524f1e46526b1">&#9670;&#160;</a></span>copyImageToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::copyImageToImage </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offsetX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offsetY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an image to another image. </p>
<p>Fill a command buffer with a copy command in order to copy an image to another image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The source image </td></tr>
    <tr><td class="paramname">dstImage</td><td>The destination image </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image </td></tr>
    <tr><td class="paramname">offsetX</td><td>An offset on the X axis </td></tr>
    <tr><td class="paramname">offsetY</td><td>An offset on the Y axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4f1ce22ec25aa3234ca4a539d09213" name="acc4f1ce22ec25aa3234ca4a539d09213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f1ce22ec25aa3234ca4a539d09213">&#9670;&#160;</a></span>endSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::endSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1vulkan_1_1Context_1_1SingleTimeCommand.html">SingleTimeCommand</a>&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End a single time command. </p>
<p>If the command type is DIRECT_EXECUTION, the command is queued to the graphics queue and is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2b48b2ad5cfac87a465e238372d2aa" name="a2c2b48b2ad5cfac87a465e238372d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2b48b2ad5cfac87a465e238372d2aa">&#9670;&#160;</a></span>enumerateExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fge::vulkan::Context::enumerateExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate to standard output the available extensions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1vulkan_1_1Context.html#a5a39d50bd352ea970756dbb55202d384" title="Retrieve the available extensions.">retrieveExtensions()</a> </dd></dl>

</div>
</div>
<a id="ab251473f8bb90da8488a76003ccd0660" name="ab251473f8bb90da8488a76003ccd0660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab251473f8bb90da8488a76003ccd0660">&#9670;&#160;</a></span>getAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VmaAllocator fge::vulkan::Context::getAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the VMA (Vulkan Memory Allocator) </p>
<dl class="section return"><dt>Returns</dt><dd>The allocator </dd></dl>

</div>
</div>
<a id="af8b13069b2be507a3b7e893bbf9a5cbc" name="af8b13069b2be507a3b7e893bbf9a5cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b13069b2be507a3b7e893bbf9a5cbc">&#9670;&#160;</a></span>getCacheLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp; fge::vulkan::Context::getCacheLayout </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve or create a descriptor set layout from a key. </p>
<p>Certain objects need a custom descriptor set layout to be created for custom shaders.</p>
<p>If the descriptor set layout is not already created, it will be created and cached and you will be able to fill it with the necessary bindings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to retrieve the descriptor set layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The descriptor set layout </dd></dl>

</div>
</div>
<a id="a10398b1b0a4c2ee3d8beb13d7a9e6cf0" name="a10398b1b0a4c2ee3d8beb13d7a9e6cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10398b1b0a4c2ee3d8beb13d7a9e6cf0">&#9670;&#160;</a></span>getGraphicsCommandBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; VkCommandBuffer &gt; const  &amp; fge::vulkan::Context::getGraphicsCommandBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the list of executable graphics command buffers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1vulkan_1_1Context.html#a59403de6ca040b775692b411b433f218" title="Push a graphics command buffer to a list.">pushGraphicsCommandBuffer()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The list of executable graphics command buffers </dd></dl>

</div>
</div>
<a id="ab7dbe534fa869f54ec37cb138edccaa3" name="ab7dbe534fa869f54ec37cb138edccaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dbe534fa869f54ec37cb138edccaa3">&#9670;&#160;</a></span>getGraphicsCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool fge::vulkan::Context::getGraphicsCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a command pool for graphics commands. </p>
<p>This command pool is used to create command buffers that will be used to submit commands to the graphics queue.</p>
<p>This command pool is created with the following flags: VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</p>
<dl class="section return"><dt>Returns</dt><dd>The command pool </dd></dl>

</div>
</div>
<a id="a7e0250fa583b569a008469cc427879c1" name="a7e0250fa583b569a008469cc427879c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0250fa583b569a008469cc427879c1">&#9670;&#160;</a></span>getMultiUseDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp; fge::vulkan::Context::getMultiUseDescriptorPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "multi-usage" descriptor pool. </p>
<p>This pool was created with the following types: VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</p>
<dl class="section return"><dt>Returns</dt><dd>The descriptor pool </dd></dl>

</div>
</div>
<a id="a08fb97ddcb7699cb7eda8acc3dc772c4" name="a08fb97ddcb7699cb7eda8acc3dc772c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb97ddcb7699cb7eda8acc3dc772c4">&#9670;&#160;</a></span>getOutsideRenderScopeSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSemaphore fge::vulkan::Context::getOutsideRenderScopeSemaphore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the semaphore that is signaled when the outside render scope command buffer have finished executing. </p>
<p>This can return VK_NULL_HANDLE if the command buffer doesn't have any command to execute.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1vulkan_1_1Context.html#aa286e856957b06e10b00bcd81fd3c59d" title="Submit Context command buffers.">submit()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The semaphore </dd></dl>

</div>
</div>
<a id="a91521a0463be4b0026ea8c1abe17eb96" name="a91521a0463be4b0026ea8c1abe17eb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91521a0463be4b0026ea8c1abe17eb96">&#9670;&#160;</a></span>getTextureDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp; fge::vulkan::Context::getTextureDescriptorPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "texture" descriptor pool. </p>
<p>This pool can only contain VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type.</p>
<dl class="section return"><dt>Returns</dt><dd>The descriptor pool </dd></dl>

</div>
</div>
<a id="ad4f4594e9357f051596621f0d3373c56" name="ad4f4594e9357f051596621f0d3373c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f4594e9357f051596621f0d3373c56">&#9670;&#160;</a></span>getTextureLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp; fge::vulkan::Context::getTextureLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "texture" descriptor set layout. </p>
<p>This layout is used with default provided shaders.</p>
<p>This layout was created with the following: binding: FGE_VULKAN_TEXTURE_BINDING type: VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER stage: VK_SHADER_STAGE_FRAGMENT_BIT</p>
<dl class="section return"><dt>Returns</dt><dd>The descriptor set layout </dd></dl>

</div>
</div>
<a id="a820427b1ceef9aaac9cbcf88a90e15a7" name="a820427b1ceef9aaac9cbcf88a90e15a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820427b1ceef9aaac9cbcf88a90e15a7">&#9670;&#160;</a></span>getTransformDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorPool.html">DescriptorPool</a> &amp; fge::vulkan::Context::getTransformDescriptorPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "transform" descriptor pool. </p>
<p>This pool can only contain VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER type.</p>
<dl class="section return"><dt>Returns</dt><dd>The descriptor pool </dd></dl>

</div>
</div>
<a id="ad5e7803b72427c8f94d35e3b0ef63217" name="ad5e7803b72427c8f94d35e3b0ef63217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e7803b72427c8f94d35e3b0ef63217">&#9670;&#160;</a></span>getTransformLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfge_1_1vulkan_1_1DescriptorSetLayout.html">fge::vulkan::DescriptorSetLayout</a> &amp; fge::vulkan::Context::getTransformLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a "transform" descriptor set layout. </p>
<p>This layout is used with default provided shaders.</p>
<p>This layout was created with the following: binding: FGE_VULKAN_TRANSFORM_BINDING type: VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER stage: VK_SHADER_STAGE_VERTEX_BIT</p>
<dl class="section return"><dt>Returns</dt><dd>The descriptor set layout </dd></dl>

</div>
</div>
<a id="a92724656e6294b1be733cdf931078fa5" name="a92724656e6294b1be733cdf931078fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92724656e6294b1be733cdf931078fa5">&#9670;&#160;</a></span>initVolk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fge::vulkan::Context::initVolk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Volk (Vulkan loader) </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called once before any other graphics usage, generally at the start of the program </dd></dl>

</div>
</div>
<a id="a5151236d85c7135d573532bea41633d6" name="a5151236d85c7135d573532bea41633d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5151236d85c7135d573532bea41633d6">&#9670;&#160;</a></span>initVulkan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::initVulkan </td>
          <td>(</td>
          <td class="paramtype">SDL_Window *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Vulkan. </p>
<p>Once a SDL window is correctly created, this function must be called to initialize Vulkan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The SDL window </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59403de6ca040b775692b411b433f218" name="a59403de6ca040b775692b411b433f218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59403de6ca040b775692b411b433f218">&#9670;&#160;</a></span>pushGraphicsCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::pushGraphicsCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a graphics command buffer to a list. </p>
<p>This is used to keep track of executable command buffers that will be submitted to the graphics queue. This list must be cleared once the command buffers are submitted. Generally, this is done by a RenderScreen when the RenderScreen::display() method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a39d50bd352ea970756dbb55202d384" name="a5a39d50bd352ea970756dbb55202d384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a39d50bd352ea970756dbb55202d384">&#9670;&#160;</a></span>retrieveExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::string &gt; fge::vulkan::Context::retrieveExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the available extensions. </p>
<dl class="section return"><dt>Returns</dt><dd>The available extensions </dd></dl>

</div>
</div>
<a id="aa286e856957b06e10b00bcd81fd3c59d" name="aa286e856957b06e10b00bcd81fd3c59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa286e856957b06e10b00bcd81fd3c59d">&#9670;&#160;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::submit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit <a class="el" href="classfge_1_1vulkan_1_1Context.html" title="Vulkan context.">Context</a> command buffers. </p>
<p>outsideRenderScopeCommandBuffers are submitted with a semaphore that is signaled when the command buffers have finished executing.</p>
<p>The semaphore should be retrieved with <a class="el" href="classfge_1_1vulkan_1_1Context.html#a08fb97ddcb7699cb7eda8acc3dc772c4" title="Retrieve the semaphore that is signaled when the outside render scope command buffer have finished ex...">getOutsideRenderScopeSemaphore()</a> and you must wait for it to be signaled before rendering commands as this buffer generally contain some buffer transfer operations.</p>
<p>This also increment the internal current frame counter.</p>
<p>This is automatically called by a RenderScreen when the RenderScreen::display() method is called. </p>

</div>
</div>
<a id="ae019452672384d90cdf28ed8b8b7d49a" name="ae019452672384d90cdf28ed8b8b7d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae019452672384d90cdf28ed8b8b7d49a">&#9670;&#160;</a></span>transitionImageLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::transitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an image layout. </p>
<p>Fill a command buffer with a transition command in order to transition an image layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image </td></tr>
    <tr><td class="paramname">format</td><td>The format of the image </td></tr>
    <tr><td class="paramname">oldLayout</td><td>The old layout </td></tr>
    <tr><td class="paramname">newLayout</td><td>The new layout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4839c3c2698193424d930eb0b9ef7138" name="a4839c3c2698193424d930eb0b9ef7138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4839c3c2698193424d930eb0b9ef7138">&#9670;&#160;</a></span>waitIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::vulkan::Context::waitIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the device to be idle. </p>
<p>This is generally called before any new commands submission. Also when the program is about to exit, this function must be called to make sure that all commands are finished. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="C__context_8hpp_source.html">C_context.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
