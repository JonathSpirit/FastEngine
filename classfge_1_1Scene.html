<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastEngine: fge::Scene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FastEngine<span id="projectnumber">&#160;0.9.2</span>
   </div>
   <div id="projectbrief">A multiplayer oriented 2D engine made with Vulkan.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fge</b></li><li class="navelem"><a class="el" href="classfge_1_1Scene.html">Scene</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classfge_1_1Scene-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fge::Scene Class Reference<div class="ingroups"><a class="el" href="group__objectControl.html">Object control</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A scene contain a collection of object and handle them.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="C__scene_8hpp_source.html">C_scene.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fge::Scene:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfge_1_1Scene.png" usemap="#fge::Scene_map" alt=""/>
  <map id="fge::Scene_map" name="fge::Scene_map">
<area href="classfge_1_1CommandHandler.html" title="CommandHandler is a class that can be used to handle commands." alt="fge::CommandHandler" shape="rect" coords="0,0,136,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a676b4cc552e47207c903d20e30406273" id="r_a676b4cc552e47207c903d20e30406273"><td class="memItemLeft" align="right" valign="top"><a id="a676b4cc552e47207c903d20e30406273" name="a676b4cc552e47207c903d20e30406273"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFlags</b> : uint32_t { <b>NONE</b> = 0
, <b>INCREMENT_UPDATE_COUNT</b> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="separator:a676b4cc552e47207c903d20e30406273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e2f69c529acaa17ab5a329eb33353f" id="r_ad2e2f69c529acaa17ab5a329eb33353f"><td class="memItemLeft" align="right" valign="top"><a id="ad2e2f69c529acaa17ab5a329eb33353f" name="ad2e2f69c529acaa17ab5a329eb33353f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NetworkEventQueue</b> = std::queue&lt;<a class="el" href="structfge_1_1SceneNetEvent.html">fge::SceneNetEvent</a>&gt;</td></tr>
<tr class="separator:ad2e2f69c529acaa17ab5a329eb33353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63495249787c86a5afea2958d7d58c9d" id="r_a63495249787c86a5afea2958d7d58c9d"><td class="memItemLeft" align="right" valign="top"><a id="a63495249787c86a5afea2958d7d58c9d" name="a63495249787c86a5afea2958d7d58c9d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CommandDataType</b> = std::vector&lt;<a class="el" href="structfge_1_1CommandHandler_1_1CommandData.html">fge::CommandHandler::CommandData</a>&gt;</td></tr>
<tr class="separator:a63495249787c86a5afea2958d7d58c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3bc6dcba8534e1cb2531e2d29cfb1a90" id="r_a3bc6dcba8534e1cb2531e2d29cfb1a90"><td class="memItemLeft" align="right" valign="top"><a id="a3bc6dcba8534e1cb2531e2d29cfb1a90" name="a3bc6dcba8534e1cb2531e2d29cfb1a90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (std::string sceneName)</td></tr>
<tr class="separator:a3bc6dcba8534e1cb2531e2d29cfb1a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05690bff64a7f843a04ebdc1986c3c2" id="r_ae05690bff64a7f843a04ebdc1986c3c2"><td class="memItemLeft" align="right" valign="top"><a id="ae05690bff64a7f843a04ebdc1986c3c2" name="ae05690bff64a7f843a04ebdc1986c3c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (<a class="el" href="classfge_1_1Scene.html">Scene</a> const &amp;r)</td></tr>
<tr class="separator:ae05690bff64a7f843a04ebdc1986c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a8f3b5ac7058b1252266505d42cc0" id="r_a2c8a8f3b5ac7058b1252266505d42cc0"><td class="memItemLeft" align="right" valign="top"><a id="a2c8a8f3b5ac7058b1252266505d42cc0" name="a2c8a8f3b5ac7058b1252266505d42cc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (<a class="el" href="classfge_1_1Scene.html">Scene</a> &amp;&amp;r) noexcept=delete</td></tr>
<tr class="separator:a2c8a8f3b5ac7058b1252266505d42cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35d2d9e171ff98a23094481187c67d2" id="r_ae35d2d9e171ff98a23094481187c67d2"><td class="memItemLeft" align="right" valign="top"><a id="ae35d2d9e171ff98a23094481187c67d2" name="ae35d2d9e171ff98a23094481187c67d2"></a>
<a class="el" href="classfge_1_1Scene.html">Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classfge_1_1Scene.html">Scene</a> const &amp;r)</td></tr>
<tr class="separator:ae35d2d9e171ff98a23094481187c67d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255b62d94f0291965829913934c202ea" id="r_a255b62d94f0291965829913934c202ea"><td class="memItemLeft" align="right" valign="top"><a id="a255b62d94f0291965829913934c202ea" name="a255b62d94f0291965829913934c202ea"></a>
<a class="el" href="classfge_1_1Scene.html">Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classfge_1_1Scene.html">Scene</a> &amp;&amp;r) noexcept=delete</td></tr>
<tr class="separator:a255b62d94f0291965829913934c202ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51b387a37caf9e539021120bcfe937e" id="r_ae51b387a37caf9e539021120bcfe937e"><td class="memItemLeft" align="right" valign="top">std::string const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51b387a37caf9e539021120bcfe937e">getName</a> () const</td></tr>
<tr class="memdesc:ae51b387a37caf9e539021120bcfe937e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:ae51b387a37caf9e539021120bcfe937e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12af96b94b0e41650589ba79514c134f" id="r_a12af96b94b0e41650589ba79514c134f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12af96b94b0e41650589ba79514c134f">setName</a> (std::string name)</td></tr>
<tr class="memdesc:a12af96b94b0e41650589ba79514c134f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a12af96b94b0e41650589ba79514c134f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1bca7b135815669dba730aab11f61d" id="r_a4b1bca7b135815669dba730aab11f61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b1bca7b135815669dba730aab11f61d">update</a> (<a class="el" href="classfge_1_1RenderWindow.html">fge::RenderWindow</a> &amp;screen, <a class="el" href="classfge_1_1Event.html">fge::Event</a> &amp;event, std::chrono::microseconds const &amp;deltaTime, std::underlying_type_t&lt; UpdateFlags &gt; flags=UpdateFlags::NONE)</td></tr>
<tr class="memdesc:a4b1bca7b135815669dba730aab11f61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a4b1bca7b135815669dba730aab11f61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2361734d3daa31588ee75b5b5531052b" id="r_a2361734d3daa31588ee75b5b5531052b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2361734d3daa31588ee75b5b5531052b">getUpdateCount</a> () const</td></tr>
<tr class="memdesc:a2361734d3daa31588ee75b5b5531052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of update.  <br /></td></tr>
<tr class="separator:a2361734d3daa31588ee75b5b5531052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a158566c6cb15351ad5957809fac14" id="r_a81a158566c6cb15351ad5957809fac14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a158566c6cb15351ad5957809fac14">draw</a> (<a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> &amp;target, <a class="el" href="classfge_1_1RenderStates.html">fge::RenderStates</a> const &amp;states={}) const</td></tr>
<tr class="memdesc:a81a158566c6cb15351ad5957809fac14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a81a158566c6cb15351ad5957809fac14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ecef294e7c2f0bd21f6c8a278d6d87" id="r_ab6ecef294e7c2f0bd21f6c8a278d6d87"><td class="memItemLeft" align="right" valign="top">fge::ObjectPlanDepth&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ecef294e7c2f0bd21f6c8a278d6d87">updatePlanDepth</a> (fge::ObjectSid sid)</td></tr>
<tr class="memdesc:ab6ecef294e7c2f0bd21f6c8a278d6d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the ObjectPlanDepth for one object  <br /></td></tr>
<tr class="separator:ab6ecef294e7c2f0bd21f6c8a278d6d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d58a5aeb3cf0bb800203cc9421d9b2" id="r_a15d58a5aeb3cf0bb800203cc9421d9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d58a5aeb3cf0bb800203cc9421d9b2">updateAllPlanDepth</a> (fge::ObjectPlan plan)</td></tr>
<tr class="memdesc:a15d58a5aeb3cf0bb800203cc9421d9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the ObjectPlanDepth for every objects inside the same plan  <br /></td></tr>
<tr class="separator:a15d58a5aeb3cf0bb800203cc9421d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251b5846d699bf47b1f4304b9108663c" id="r_a251b5846d699bf47b1f4304b9108663c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251b5846d699bf47b1f4304b9108663c">updateAllPlanDepth</a> ()</td></tr>
<tr class="memdesc:a251b5846d699bf47b1f4304b9108663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the ObjectPlanDepth for every objects  <br /></td></tr>
<tr class="separator:a251b5846d699bf47b1f4304b9108663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b3edd8f27787fe0a34cd8a58212bc" id="r_a134b3edd8f27787fe0a34cd8a58212bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134b3edd8f27787fe0a34cd8a58212bc">clear</a> ()</td></tr>
<tr class="memdesc:a134b3edd8f27787fe0a34cd8a58212bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a134b3edd8f27787fe0a34cd8a58212bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccfa1288c2909a7b1e9bea3c4ae12cd" id="r_a9ccfa1288c2909a7b1e9bea3c4ae12cd"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ccfa1288c2909a7b1e9bea3c4ae12cd">newObject</a> (fge::ObjectPtr &amp;&amp;newObject, fge::ObjectPlan plan=fge::ObjectPlan { 100 }, fge::ObjectSid sid=std::numeric_limits&lt; fge::ObjectSid &gt;::max(), <a class="el" href="group__objectControl.html#ga6d371b22ba3b898839c934bd4501c284">fge::ObjectType</a> type=fge::ObjectType::TYPE_OBJECT, bool silent=false)</td></tr>
<tr class="memdesc:a9ccfa1288c2909a7b1e9bea3c4ae12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a9ccfa1288c2909a7b1e9bea3c4ae12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af590bed5f9b9cbc4b80f839da1c2b3fa" id="r_af590bed5f9b9cbc4b80f839da1c2b3fa"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af590bed5f9b9cbc4b80f839da1c2b3fa">newObject</a> (fge::ObjectDataShared const &amp;objectData, bool silent=false)</td></tr>
<tr class="memdesc:af590bed5f9b9cbc4b80f839da1c2b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:af590bed5f9b9cbc4b80f839da1c2b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b67037f9d1674d42139454ee0dd56f4" id="r_a2b67037f9d1674d42139454ee0dd56f4"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b67037f9d1674d42139454ee0dd56f4">duplicateObject</a> (fge::ObjectSid sid, fge::ObjectSid newSid=std::numeric_limits&lt; fge::ObjectSid &gt;::max())</td></tr>
<tr class="memdesc:a2b67037f9d1674d42139454ee0dd56f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the provided <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> SID.  <br /></td></tr>
<tr class="separator:a2b67037f9d1674d42139454ee0dd56f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d177f7c0ddb45997668532f91fc1b4" id="r_a75d177f7c0ddb45997668532f91fc1b4"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d177f7c0ddb45997668532f91fc1b4">transferObject</a> (fge::ObjectSid sid, <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> &amp;newScene)</td></tr>
<tr class="memdesc:a75d177f7c0ddb45997668532f91fc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the specified <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to another <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a75d177f7c0ddb45997668532f91fc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b92bf6ebe18b65e05548e14bd22798" id="r_ac3b92bf6ebe18b65e05548e14bd22798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3b92bf6ebe18b65e05548e14bd22798">delUpdatedObject</a> ()</td></tr>
<tr class="memdesc:ac3b92bf6ebe18b65e05548e14bd22798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the actual updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>.  <br /></td></tr>
<tr class="separator:ac3b92bf6ebe18b65e05548e14bd22798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6058721874450172e3b8c0dfe5ef793a" id="r_a6058721874450172e3b8c0dfe5ef793a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6058721874450172e3b8c0dfe5ef793a">delObject</a> (fge::ObjectSid sid)</td></tr>
<tr class="memdesc:a6058721874450172e3b8c0dfe5ef793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> provided with his SID.  <br /></td></tr>
<tr class="separator:a6058721874450172e3b8c0dfe5ef793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd52b6a9ba0b39f4e66114e1abf37c2" id="r_a5fd52b6a9ba0b39f4e66114e1abf37c2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd52b6a9ba0b39f4e66114e1abf37c2">delAllObject</a> (bool ignoreGuiObject)</td></tr>
<tr class="memdesc:a5fd52b6a9ba0b39f4e66114e1abf37c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a5fd52b6a9ba0b39f4e66114e1abf37c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b04bf715eec7bb77466df34b117ad01" id="r_a9b04bf715eec7bb77466df34b117ad01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b04bf715eec7bb77466df34b117ad01">setObjectSid</a> (fge::ObjectSid sid, fge::ObjectSid newSid)</td></tr>
<tr class="memdesc:a9b04bf715eec7bb77466df34b117ad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a new SID.  <br /></td></tr>
<tr class="separator:a9b04bf715eec7bb77466df34b117ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531e9afb32984550bc6b0690029f8125" id="r_a531e9afb32984550bc6b0690029f8125"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531e9afb32984550bc6b0690029f8125">setObject</a> (fge::ObjectSid sid, fge::ObjectPtr &amp;&amp;<a class="el" href="#a9ccfa1288c2909a7b1e9bea3c4ae12cd">newObject</a>)</td></tr>
<tr class="memdesc:a531e9afb32984550bc6b0690029f8125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer in place of the provided one.  <br /></td></tr>
<tr class="separator:a531e9afb32984550bc6b0690029f8125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f474bb0c8a7ad623cd01a928aaf02" id="r_ad98f474bb0c8a7ad623cd01a928aaf02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98f474bb0c8a7ad623cd01a928aaf02">setObjectPlan</a> (fge::ObjectSid sid, fge::ObjectPlan newPlan)</td></tr>
<tr class="memdesc:ad98f474bb0c8a7ad623cd01a928aaf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> plan.  <br /></td></tr>
<tr class="separator:ad98f474bb0c8a7ad623cd01a928aaf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc5619ea7889f3108eb341b3fbc9f84" id="r_a9dc5619ea7889f3108eb341b3fbc9f84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dc5619ea7889f3108eb341b3fbc9f84">setObjectPlanTop</a> (fge::ObjectSid sid)</td></tr>
<tr class="memdesc:a9dc5619ea7889f3108eb341b3fbc9f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> on top of his plan.  <br /></td></tr>
<tr class="separator:a9dc5619ea7889f3108eb341b3fbc9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc04cfdb2202e64dc16b5576a87e661" id="r_adcc04cfdb2202e64dc16b5576a87e661"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc04cfdb2202e64dc16b5576a87e661">setObjectPlanBot</a> (fge::ObjectSid sid)</td></tr>
<tr class="memdesc:adcc04cfdb2202e64dc16b5576a87e661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the bottom of his plan.  <br /></td></tr>
<tr class="separator:adcc04cfdb2202e64dc16b5576a87e661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858d56bc173593923b10f14de42d2acc" id="r_a858d56bc173593923b10f14de42d2acc"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a858d56bc173593923b10f14de42d2acc">getObject</a> (fge::ObjectSid sid) const</td></tr>
<tr class="memdesc:a858d56bc173593923b10f14de42d2acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with his SID.  <br /></td></tr>
<tr class="separator:a858d56bc173593923b10f14de42d2acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1883edecf98c70f9eb914f3e3e8313a" id="r_af1883edecf98c70f9eb914f3e3e8313a"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1883edecf98c70f9eb914f3e3e8313a">getObject</a> (<a class="el" href="classfge_1_1Object.html">fge::Object</a> const *ptr) const</td></tr>
<tr class="memdesc:af1883edecf98c70f9eb914f3e3e8313a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with his pointer.  <br /></td></tr>
<tr class="separator:af1883edecf98c70f9eb914f3e3e8313a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66f063fd2f32e840e927e6e1c13d1b" id="r_a2e66f063fd2f32e840e927e6e1c13d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1Object.html">fge::Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e66f063fd2f32e840e927e6e1c13d1b">getObjectPtr</a> (fge::ObjectSid sid) const</td></tr>
<tr class="memdesc:a2e66f063fd2f32e840e927e6e1c13d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer with his SID.  <br /></td></tr>
<tr class="separator:a2e66f063fd2f32e840e927e6e1c13d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af570e03e4071aa8b8d187b9784ecec48" id="r_af570e03e4071aa8b8d187b9784ecec48"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af570e03e4071aa8b8d187b9784ecec48">getUpdatedObject</a> () const</td></tr>
<tr class="memdesc:af570e03e4071aa8b8d187b9784ecec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>.  <br /></td></tr>
<tr class="separator:af570e03e4071aa8b8d187b9784ecec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379d5833cca1706dd800b2b0a779443c" id="r_a379d5833cca1706dd800b2b0a779443c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379d5833cca1706dd800b2b0a779443c">getObjectSize</a> () const</td></tr>
<tr class="memdesc:a379d5833cca1706dd800b2b0a779443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> stored in this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a379d5833cca1706dd800b2b0a779443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb6eb4893954842a1915e8d7fc3c718" id="r_afcb6eb4893954842a1915e8d7fc3c718"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb6eb4893954842a1915e8d7fc3c718">getAllObj_ByPosition</a> (fge::Vector2f const &amp;pos, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:afcb6eb4893954842a1915e8d7fc3c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a position.  <br /></td></tr>
<tr class="separator:afcb6eb4893954842a1915e8d7fc3c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c82022744dd4de6a84cb6d364de42d6" id="r_a3c82022744dd4de6a84cb6d364de42d6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c82022744dd4de6a84cb6d364de42d6">getAllObj_ByZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectFloat</a> const &amp;zone, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:a3c82022744dd4de6a84cb6d364de42d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a zone (or rectangle).  <br /></td></tr>
<tr class="separator:a3c82022744dd4de6a84cb6d364de42d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94038fe5a510f75997f9a7adadf051a9" id="r_a94038fe5a510f75997f9a7adadf051a9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94038fe5a510f75997f9a7adadf051a9">getAllObj_ByLocalPosition</a> (fge::Vector2i const &amp;pos, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:a94038fe5a510f75997f9a7adadf051a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position.  <br /></td></tr>
<tr class="separator:a94038fe5a510f75997f9a7adadf051a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3de1ea78b412310c23385e15da556d" id="r_aba3de1ea78b412310c23385e15da556d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3de1ea78b412310c23385e15da556d">getAllObj_ByLocalZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;zone, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:aba3de1ea78b412310c23385e15da556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone (or rectangle).  <br /></td></tr>
<tr class="separator:aba3de1ea78b412310c23385e15da556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4741a3f3d76efcba519a1704d60cc3d" id="r_ab4741a3f3d76efcba519a1704d60cc3d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4741a3f3d76efcba519a1704d60cc3d">getAllObj_FromLocalPosition</a> (fge::Vector2i const &amp;pos, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:ab4741a3f3d76efcba519a1704d60cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position.  <br /></td></tr>
<tr class="separator:ab4741a3f3d76efcba519a1704d60cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e40feb16e3f09349433258f293e687c" id="r_a8e40feb16e3f09349433258f293e687c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e40feb16e3f09349433258f293e687c">getAllObj_FromLocalZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;zone, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:a8e40feb16e3f09349433258f293e687c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone (or rectangle).  <br /></td></tr>
<tr class="separator:a8e40feb16e3f09349433258f293e687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a093fdda11e644a295f4dfbed2086e" id="r_a60a093fdda11e644a295f4dfbed2086e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a093fdda11e644a295f4dfbed2086e">getAllObj_ByClass</a> (std::string_view class_name, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:a60a093fdda11e644a295f4dfbed2086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the same class name.  <br /></td></tr>
<tr class="separator:a60a093fdda11e644a295f4dfbed2086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb3405d407179102a4df8d0f9e17e45" id="r_aedb3405d407179102a4df8d0f9e17e45"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb3405d407179102a4df8d0f9e17e45">getAllObj_ByTag</a> (std::string_view tag_name, fge::ObjectContainer &amp;buff) const</td></tr>
<tr class="memdesc:aedb3405d407179102a4df8d0f9e17e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that contain the provided tag.  <br /></td></tr>
<tr class="separator:aedb3405d407179102a4df8d0f9e17e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27288a15502249dcdb32ed04f616c466" id="r_a27288a15502249dcdb32ed04f616c466"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27288a15502249dcdb32ed04f616c466">getFirstObj_ByPosition</a> (fge::Vector2f const &amp;pos) const</td></tr>
<tr class="memdesc:a27288a15502249dcdb32ed04f616c466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a position.  <br /></td></tr>
<tr class="separator:a27288a15502249dcdb32ed04f616c466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84d0774b945b905ba41d254b0bb1dcf" id="r_aa84d0774b945b905ba41d254b0bb1dcf"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa84d0774b945b905ba41d254b0bb1dcf">getFirstObj_ByZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectFloat</a> const &amp;zone) const</td></tr>
<tr class="memdesc:aa84d0774b945b905ba41d254b0bb1dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a zone.  <br /></td></tr>
<tr class="separator:aa84d0774b945b905ba41d254b0bb1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a87ee6b21e6b7c7c77c22304eae36b" id="r_af5a87ee6b21e6b7c7c77c22304eae36b"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a87ee6b21e6b7c7c77c22304eae36b">getFirstObj_ByLocalPosition</a> (fge::Vector2i const &amp;pos, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target) const</td></tr>
<tr class="memdesc:af5a87ee6b21e6b7c7c77c22304eae36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position.  <br /></td></tr>
<tr class="separator:af5a87ee6b21e6b7c7c77c22304eae36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3693d8c66e93813270c877b17fbf9e4c" id="r_a3693d8c66e93813270c877b17fbf9e4c"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3693d8c66e93813270c877b17fbf9e4c">getFirstObj_ByLocalZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;zone, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target) const</td></tr>
<tr class="memdesc:a3693d8c66e93813270c877b17fbf9e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone.  <br /></td></tr>
<tr class="separator:a3693d8c66e93813270c877b17fbf9e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3099db3370212a5a384b22cd413676" id="r_abd3099db3370212a5a384b22cd413676"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd3099db3370212a5a384b22cd413676">getFirstObj_FromLocalPosition</a> (fge::Vector2i const &amp;pos, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target) const</td></tr>
<tr class="memdesc:abd3099db3370212a5a384b22cd413676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position position.  <br /></td></tr>
<tr class="separator:abd3099db3370212a5a384b22cd413676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eed46196c9c4cb1e37c431fda86e57" id="r_a43eed46196c9c4cb1e37c431fda86e57"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43eed46196c9c4cb1e37c431fda86e57">getFirstObj_FromLocalZone</a> (<a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;zone, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;target) const</td></tr>
<tr class="memdesc:a43eed46196c9c4cb1e37c431fda86e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone.  <br /></td></tr>
<tr class="separator:a43eed46196c9c4cb1e37c431fda86e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f40001a17fa427e7fa09e17b8e240" id="r_a2e0f40001a17fa427e7fa09e17b8e240"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e0f40001a17fa427e7fa09e17b8e240">getFirstObj_ByClass</a> (std::string_view class_name) const</td></tr>
<tr class="memdesc:a2e0f40001a17fa427e7fa09e17b8e240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match a provided class name.  <br /></td></tr>
<tr class="separator:a2e0f40001a17fa427e7fa09e17b8e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb518824319d6faab3c0245926978dbd" id="r_abb518824319d6faab3c0245926978dbd"><td class="memItemLeft" align="right" valign="top">fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb518824319d6faab3c0245926978dbd">getFirstObj_ByTag</a> (std::string_view tag_name) const</td></tr>
<tr class="memdesc:abb518824319d6faab3c0245926978dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match a provided tag.  <br /></td></tr>
<tr class="separator:abb518824319d6faab3c0245926978dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be180b9ffe8970e3908063b282c4f58" id="r_a3be180b9ffe8970e3908063b282c4f58"><td class="memItemLeft" align="right" valign="top">fge::ObjectSid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be180b9ffe8970e3908063b282c4f58">getSid</a> (<a class="el" href="classfge_1_1Object.html">fge::Object</a> const *ptr) const</td></tr>
<tr class="memdesc:a3be180b9ffe8970e3908063b282c4f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SID of the provided <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer.  <br /></td></tr>
<tr class="separator:a3be180b9ffe8970e3908063b282c4f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925832b373e45368c78c642829a8d615" id="r_a925832b373e45368c78c642829a8d615"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a925832b373e45368c78c642829a8d615">isValid</a> (fge::ObjectSid sid) const</td></tr>
<tr class="memdesc:a925832b373e45368c78c642829a8d615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the SID correspond to an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a925832b373e45368c78c642829a8d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe590c8fc034b6435c1c83c8c484be08" id="r_abe590c8fc034b6435c1c83c8c484be08"><td class="memItemLeft" align="right" valign="top">virtual fge::ObjectSid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe590c8fc034b6435c1c83c8c484be08">generateSid</a> (fge::ObjectSid wanted_sid=std::numeric_limits&lt; fge::ObjectSid &gt;::max()) const</td></tr>
<tr class="memdesc:abe590c8fc034b6435c1c83c8c484be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an SID based on the provided wanted SID.  <br /></td></tr>
<tr class="separator:abe590c8fc034b6435c1c83c8c484be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a9e75a5e156fe96f28e3180f3cff7d" id="r_a76a9e75a5e156fe96f28e3180f3cff7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a9e75a5e156fe96f28e3180f3cff7d">pack</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;pck)</td></tr>
<tr class="memdesc:a76a9e75a5e156fe96f28e3180f3cff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data in a Packet.  <br /></td></tr>
<tr class="separator:a76a9e75a5e156fe96f28e3180f3cff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98deb4840dd20aea4d4e9a1a5cd7303" id="r_ac98deb4840dd20aea4d4e9a1a5cd7303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98deb4840dd20aea4d4e9a1a5cd7303">pack</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;pck, <a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:ac98deb4840dd20aea4d4e9a1a5cd7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data in a Packet for a <a class="el" href="classfge_1_1net_1_1Client.html" title="Class that represent the identity of a client.">net::Client</a>.  <br /></td></tr>
<tr class="separator:ac98deb4840dd20aea4d4e9a1a5cd7303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679edf7567a83d8008482aa777e2ab8d" id="r_a679edf7567a83d8008482aa777e2ab8d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679edf7567a83d8008482aa777e2ab8d">unpack</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck)</td></tr>
<tr class="memdesc:a679edf7567a83d8008482aa777e2ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack all the received data of a serverside <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a679edf7567a83d8008482aa777e2ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c93e6fbc04ac4be98bb7951e06760f1" id="r_a7c93e6fbc04ac4be98bb7951e06760f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c93e6fbc04ac4be98bb7951e06760f1">packModification</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;pck, <a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:a7c93e6fbc04ac4be98bb7951e06760f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack all modification in a <a class="el" href="classfge_1_1net_1_1Packet.html">net::Packet</a> for a <a class="el" href="classfge_1_1net_1_1Client.html" title="Class that represent the identity of a client.">net::Client</a>.  <br /></td></tr>
<tr class="separator:a7c93e6fbc04ac4be98bb7951e06760f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32308d155bf1be24e982d4ea5bc16b7" id="r_ad32308d155bf1be24e982d4ea5bc16b7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad32308d155bf1be24e982d4ea5bc16b7">unpackModification</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck, <a class="el" href="structfge_1_1UpdateCountRange.html">UpdateCountRange</a> &amp;updateCountRange, bool isPreExtractedPacket)</td></tr>
<tr class="memdesc:ad32308d155bf1be24e982d4ea5bc16b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack all modification of received data packet from a server.  <br /></td></tr>
<tr class="separator:ad32308d155bf1be24e982d4ea5bc16b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca7aee65c2b9df82f7cdef1ec6eb8f1" id="r_a7ca7aee65c2b9df82f7cdef1ec6eb8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca7aee65c2b9df82f7cdef1ec6eb8f1">packNeededUpdate</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;pck)</td></tr>
<tr class="memdesc:a7ca7aee65c2b9df82f7cdef1ec6eb8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack object that need an explicit update from the server.  <br /></td></tr>
<tr class="separator:a7ca7aee65c2b9df82f7cdef1ec6eb8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cac81955acf6a681d3ae4c125b8245" id="r_ab1cac81955acf6a681d3ae4c125b8245"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1cac81955acf6a681d3ae4c125b8245">unpackNeededUpdate</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck, <a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:ab1cac81955acf6a681d3ae4c125b8245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack client object that require an explicit update.  <br /></td></tr>
<tr class="separator:ab1cac81955acf6a681d3ae4c125b8245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332d7d2840f94482eed5e277f65df50a" id="r_a332d7d2840f94482eed5e277f65df50a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a332d7d2840f94482eed5e277f65df50a">forceCheckClient</a> (<a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:a332d7d2840f94482eed5e277f65df50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force every network type modification flag to be <b>true</b> for a specified client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a>.  <br /></td></tr>
<tr class="separator:a332d7d2840f94482eed5e277f65df50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463bf3908788d7eb036ee489bc22f906" id="r_a463bf3908788d7eb036ee489bc22f906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463bf3908788d7eb036ee489bc22f906">forceUncheckClient</a> (<a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:a463bf3908788d7eb036ee489bc22f906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force every network type modification flag to be <b>false</b> for a specified client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a>.  <br /></td></tr>
<tr class="separator:a463bf3908788d7eb036ee489bc22f906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593365c0a07e25a62350d44928610780" id="r_a593365c0a07e25a62350d44928610780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a593365c0a07e25a62350d44928610780">clientsCheckup</a> (<a class="el" href="classfge_1_1net_1_1ClientList.html">fge::net::ClientList</a> const &amp;clients, bool force=false)</td></tr>
<tr class="memdesc:a593365c0a07e25a62350d44928610780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a clients checkup.  <br /></td></tr>
<tr class="separator:a593365c0a07e25a62350d44928610780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37b60110653eb4c1d878fa815dd98bc" id="r_ac37b60110653eb4c1d878fa815dd98bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac37b60110653eb4c1d878fa815dd98bc">pushEvent</a> (<a class="el" href="structfge_1_1SceneNetEvent.html">fge::SceneNetEvent</a> const &amp;netEvent)</td></tr>
<tr class="memdesc:ac37b60110653eb4c1d878fa815dd98bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually push a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event for every clients.  <br /></td></tr>
<tr class="separator:ac37b60110653eb4c1d878fa815dd98bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a8f36085235ebfb900a4d66abb11ce" id="r_a31a8f36085235ebfb900a4d66abb11ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31a8f36085235ebfb900a4d66abb11ce">pushEvent</a> (<a class="el" href="structfge_1_1SceneNetEvent.html">fge::SceneNetEvent</a> const &amp;netEvent, <a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:a31a8f36085235ebfb900a4d66abb11ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually push a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event for a specified client.  <br /></td></tr>
<tr class="separator:a31a8f36085235ebfb900a4d66abb11ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae238766ad9a6fddfcec948bfe3d1e2e1" id="r_ae238766ad9a6fddfcec948bfe3d1e2e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae238766ad9a6fddfcec948bfe3d1e2e1">watchEvent</a> (bool on)</td></tr>
<tr class="memdesc:ae238766ad9a6fddfcec948bfe3d1e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start to watch <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event or not.  <br /></td></tr>
<tr class="separator:ae238766ad9a6fddfcec948bfe3d1e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b1a24eff38a6bad8e942ebd84e0f7e" id="r_a17b1a24eff38a6bad8e942ebd84e0f7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17b1a24eff38a6bad8e942ebd84e0f7e">isWatchingEvent</a> () const</td></tr>
<tr class="memdesc:a17b1a24eff38a6bad8e942ebd84e0f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is currently watching events. ".  <br /></td></tr>
<tr class="separator:a17b1a24eff38a6bad8e942ebd84e0f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d887de08c9aba5cc5b75fbe909fb7b" id="r_a24d887de08c9aba5cc5b75fbe909fb7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d887de08c9aba5cc5b75fbe909fb7b">clearNetEventsQueue</a> (<a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:a24d887de08c9aba5cc5b75fbe909fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> network events queue for the specified client.  <br /></td></tr>
<tr class="separator:a24d887de08c9aba5cc5b75fbe909fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe195957097d419c3aa8d2f0db4c2970" id="r_afe195957097d419c3aa8d2f0db4c2970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe195957097d419c3aa8d2f0db4c2970">clearNetEventsQueue</a> ()</td></tr>
<tr class="memdesc:afe195957097d419c3aa8d2f0db4c2970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> network events queue for all clients.  <br /></td></tr>
<tr class="separator:afe195957097d419c3aa8d2f0db4c2970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af9d63957efe689f35410b06c998954" id="r_a7af9d63957efe689f35410b06c998954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7af9d63957efe689f35410b06c998954">clearPerClientSyncData</a> ()</td></tr>
<tr class="memdesc:a7af9d63957efe689f35410b06c998954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all network clients related data.  <br /></td></tr>
<tr class="separator:a7af9d63957efe689f35410b06c998954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe509b2955a18efde8fdac65a12d80d" id="r_aabe509b2955a18efde8fdac65a12d80d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe509b2955a18efde8fdac65a12d80d">packWatchedEvent</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;pck, <a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;id)</td></tr>
<tr class="memdesc:aabe509b2955a18efde8fdac65a12d80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack all <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related events for a specified client.  <br /></td></tr>
<tr class="separator:aabe509b2955a18efde8fdac65a12d80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6329737994a6c1e7d33877398a98556" id="r_ae6329737994a6c1e7d33877398a98556"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6329737994a6c1e7d33877398a98556">unpackWatchedEvent</a> (<a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;pck)</td></tr>
<tr class="memdesc:ae6329737994a6c1e7d33877398a98556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack all <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related events from a server.  <br /></td></tr>
<tr class="separator:ae6329737994a6c1e7d33877398a98556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf17925173f4f97be5828469d9274411" id="r_acf17925173f4f97be5828469d9274411"><td class="memItemLeft" align="right" valign="top"><a id="acf17925173f4f97be5828469d9274411" name="acf17925173f4f97be5828469d9274411"></a>
fge::ObjectDataShared&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (fge::ObjectSid sid) const</td></tr>
<tr class="separator:acf17925173f4f97be5828469d9274411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad802b973a26fb69a7925ec0fb1b0b62c" id="r_ad802b973a26fb69a7925ec0fb1b0b62c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c">setCustomView</a> (std::shared_ptr&lt; <a class="el" href="classfge_1_1View.html">fge::View</a> &gt; customView)</td></tr>
<tr class="memdesc:ad802b973a26fb69a7925ec0fb1b0b62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom shared view.  <br /></td></tr>
<tr class="separator:ad802b973a26fb69a7925ec0fb1b0b62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78477cb4efccfe5adbd54de8eee3079e" id="r_a78477cb4efccfe5adbd54de8eee3079e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classfge_1_1View.html">fge::View</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78477cb4efccfe5adbd54de8eee3079e">getCustomView</a> () const</td></tr>
<tr class="memdesc:a78477cb4efccfe5adbd54de8eee3079e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the custom shared view if there is one.  <br /></td></tr>
<tr class="separator:a78477cb4efccfe5adbd54de8eee3079e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1843d797109901ad654b3687691bd6e3" id="r_a1843d797109901ad654b3687691bd6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1843d797109901ad654b3687691bd6e3">delCustomView</a> ()</td></tr>
<tr class="memdesc:a1843d797109901ad654b3687691bd6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the actual custom view.  <br /></td></tr>
<tr class="separator:a1843d797109901ad654b3687691bd6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951584bafb9b1bc616e0377209ef5317" id="r_a951584bafb9b1bc616e0377209ef5317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a951584bafb9b1bc616e0377209ef5317">setLinkedRenderTarget</a> (<a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> *target)</td></tr>
<tr class="memdesc:a951584bafb9b1bc616e0377209ef5317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> to the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a951584bafb9b1bc616e0377209ef5317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dce198c7b3507c54ecab506fe10d2b" id="r_a96dce198c7b3507c54ecab506fe10d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96dce198c7b3507c54ecab506fe10d2b">getLinkedRenderTarget</a> () const</td></tr>
<tr class="memdesc:a96dce198c7b3507c54ecab506fe10d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> linked to this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a96dce198c7b3507c54ecab506fe10d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51411ea28b16b80eb703ce31117311d3" id="r_a51411ea28b16b80eb703ce31117311d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51411ea28b16b80eb703ce31117311d3">getLinkedRenderTarget</a> ()</td></tr>
<tr class="memdesc:a51411ea28b16b80eb703ce31117311d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> linked to this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> (non-const).  <br /></td></tr>
<tr class="separator:a51411ea28b16b80eb703ce31117311d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2403036e442020c2e0d590da8a2dbe" id="r_a9f2403036e442020c2e0d590da8a2dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1View.html">fge::View</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f2403036e442020c2e0d590da8a2dbe">getRelatedView</a> () const</td></tr>
<tr class="memdesc:a9f2403036e442020c2e0d590da8a2dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the related view of the scene.  <br /></td></tr>
<tr class="separator:a9f2403036e442020c2e0d590da8a2dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f910bebd40741e4714be2e54cf98f11" id="r_a9f910bebd40741e4714be2e54cf98f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f910bebd40741e4714be2e54cf98f11">setCallbackContext</a> (<a class="el" href="structfge_1_1CallbackContext.html">fge::CallbackContext</a> context)</td></tr>
<tr class="memdesc:a9f910bebd40741e4714be2e54cf98f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback context of this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a9f910bebd40741e4714be2e54cf98f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b70e4aa277e8a0a200322291250c234" id="r_a2b70e4aa277e8a0a200322291250c234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfge_1_1CallbackContext.html">fge::CallbackContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b70e4aa277e8a0a200322291250c234">getCallbackContext</a> () const</td></tr>
<tr class="memdesc:a2b70e4aa277e8a0a200322291250c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback context of this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.  <br /></td></tr>
<tr class="separator:a2b70e4aa277e8a0a200322291250c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5392ac40d7e1aac17ded713661250303" id="r_a5392ac40d7e1aac17ded713661250303"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5392ac40d7e1aac17ded713661250303">saveCustomData</a> (nlohmann::json &amp;jsonObject)</td></tr>
<tr class="memdesc:a5392ac40d7e1aac17ded713661250303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save some user defined custom data.  <br /></td></tr>
<tr class="separator:a5392ac40d7e1aac17ded713661250303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6029e8c9aea4e5cc2a94603bcbaefa10" id="r_a6029e8c9aea4e5cc2a94603bcbaefa10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6029e8c9aea4e5cc2a94603bcbaefa10">loadCustomData</a> (nlohmann::json &amp;jsonObject)</td></tr>
<tr class="memdesc:a6029e8c9aea4e5cc2a94603bcbaefa10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load some user defined custom data.  <br /></td></tr>
<tr class="separator:a6029e8c9aea4e5cc2a94603bcbaefa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6edde93a552e2e2d449596331f8d728" id="r_ae6edde93a552e2e2d449596331f8d728"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6edde93a552e2e2d449596331f8d728">saveInFile</a> (std::string const &amp;path)</td></tr>
<tr class="memdesc:ae6edde93a552e2e2d449596331f8d728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> with its <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in a file.  <br /></td></tr>
<tr class="separator:ae6edde93a552e2e2d449596331f8d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2355bd9912b4ed5b1fd7707a046cfcea" id="r_a2355bd9912b4ed5b1fd7707a046cfcea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2355bd9912b4ed5b1fd7707a046cfcea">loadFromFile</a> (std::string const &amp;path)</td></tr>
<tr class="memdesc:a2355bd9912b4ed5b1fd7707a046cfcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data from a json file.  <br /></td></tr>
<tr class="separator:a2355bd9912b4ed5b1fd7707a046cfcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444074aa4a0b8b2fdf1b9a7b5014fdec" id="r_a444074aa4a0b8b2fdf1b9a7b5014fdec"><td class="memItemLeft" align="right" valign="top"><a id="a444074aa4a0b8b2fdf1b9a7b5014fdec" name="a444074aa4a0b8b2fdf1b9a7b5014fdec"></a>
fge::ObjectContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a444074aa4a0b8b2fdf1b9a7b5014fdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5d07a205903040ba937c3df75a7c56" id="r_acb5d07a205903040ba937c3df75a7c56"><td class="memItemLeft" align="right" valign="top"><a id="acb5d07a205903040ba937c3df75a7c56" name="acb5d07a205903040ba937c3df75a7c56"></a>
fge::ObjectContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:acb5d07a205903040ba937c3df75a7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b7ce9d229fa5890a9563e2870e15bc" id="r_ad0b7ce9d229fa5890a9563e2870e15bc"><td class="memItemLeft" align="right" valign="top"><a id="ad0b7ce9d229fa5890a9563e2870e15bc" name="ad0b7ce9d229fa5890a9563e2870e15bc"></a>
fge::ObjectContainer::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:ad0b7ce9d229fa5890a9563e2870e15bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe9558bfa4ed5b8c7d6a8ac79e69981" id="r_abfe9558bfa4ed5b8c7d6a8ac79e69981"><td class="memItemLeft" align="right" valign="top"><a id="abfe9558bfa4ed5b8c7d6a8ac79e69981" name="abfe9558bfa4ed5b8c7d6a8ac79e69981"></a>
fge::ObjectContainer::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:abfe9558bfa4ed5b8c7d6a8ac79e69981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6cfc624390613d0775d9b4e4d9b48b" id="r_a9a6cfc624390613d0775d9b4e4d9b48b"><td class="memItemLeft" align="right" valign="top">fge::ObjectContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a6cfc624390613d0775d9b4e4d9b48b">find</a> (fge::ObjectSid sid) const</td></tr>
<tr class="memdesc:a9a6cfc624390613d0775d9b4e4d9b48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified SID.  <br /></td></tr>
<tr class="separator:a9a6cfc624390613d0775d9b4e4d9b48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83edebc0be083c1fe2d59bd9ab2c454" id="r_ab83edebc0be083c1fe2d59bd9ab2c454"><td class="memItemLeft" align="right" valign="top">fge::ObjectContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab83edebc0be083c1fe2d59bd9ab2c454">find</a> (<a class="el" href="classfge_1_1Object.html">fge::Object</a> const *ptr) const</td></tr>
<tr class="memdesc:ab83edebc0be083c1fe2d59bd9ab2c454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer.  <br /></td></tr>
<tr class="separator:ab83edebc0be083c1fe2d59bd9ab2c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6add901c3904ea3c540e2d4bc2b0f" id="r_a76b6add901c3904ea3c540e2d4bc2b0f"><td class="memItemLeft" align="right" valign="top">fge::ObjectContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76b6add901c3904ea3c540e2d4bc2b0f">findPlan</a> (fge::ObjectPlan plan) const</td></tr>
<tr class="memdesc:a76b6add901c3904ea3c540e2d4bc2b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified plan.  <br /></td></tr>
<tr class="separator:a76b6add901c3904ea3c540e2d4bc2b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a942e9634cf7838f1266bf782627472" id="r_a7a942e9634cf7838f1266bf782627472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a7a942e9634cf7838f1266bf782627472">addCmd</a> (std::string_view name, <a class="el" href="classfge_1_1CommandHandler.html">fge::CommandHandler</a> *handle, fge::CommandFunction cmdfunc)</td></tr>
<tr class="memdesc:a7a942e9634cf7838f1266bf782627472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new command to the handler.  <br /></td></tr>
<tr class="separator:a7a942e9634cf7838f1266bf782627472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044f3a48f1b43087bf5473a933c76513" id="r_a044f3a48f1b43087bf5473a933c76513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a044f3a48f1b43087bf5473a933c76513">delCmd</a> (std::string_view name)</td></tr>
<tr class="memdesc:a044f3a48f1b43087bf5473a933c76513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a command from the handler.  <br /></td></tr>
<tr class="separator:a044f3a48f1b43087bf5473a933c76513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c716d59048bbd8bc4398685b3f3a1" id="r_aa06c716d59048bbd8bc4398685b3f3a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#aa06c716d59048bbd8bc4398685b3f3a1">replaceCmd</a> (std::string_view name, <a class="el" href="classfge_1_1CommandHandler.html">fge::CommandHandler</a> *handle, fge::CommandFunction cmdfunc)</td></tr>
<tr class="memdesc:aa06c716d59048bbd8bc4398685b3f3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a command from the handler.  <br /></td></tr>
<tr class="separator:aa06c716d59048bbd8bc4398685b3f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9063fb43f0180049875bedad48c7eb3d" id="r_a9063fb43f0180049875bedad48c7eb3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a9063fb43f0180049875bedad48c7eb3d">clearCmd</a> ()</td></tr>
<tr class="memdesc:a9063fb43f0180049875bedad48c7eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all commands from the handler.  <br /></td></tr>
<tr class="separator:a9063fb43f0180049875bedad48c7eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7bd7cbf1c44a040520a67b9cbf1663" id="r_aca7bd7cbf1c44a040520a67b9cbf1663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1Property.html">fge::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#aca7bd7cbf1c44a040520a67b9cbf1663">callCmd</a> (std::string_view name, <a class="el" href="classfge_1_1Object.html">fge::Object</a> *caller, <a class="el" href="classfge_1_1Property.html">fge::Property</a> const &amp;arg, <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *caller_scene)</td></tr>
<tr class="memdesc:aca7bd7cbf1c44a040520a67b9cbf1663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a command by its name.  <br /></td></tr>
<tr class="separator:aca7bd7cbf1c44a040520a67b9cbf1663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb20cb823d38c16aeb7b56f616d6707" id="r_a4fb20cb823d38c16aeb7b56f616d6707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1Property.html">fge::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a4fb20cb823d38c16aeb7b56f616d6707">callCmd</a> (std::size_t index, <a class="el" href="classfge_1_1Object.html">fge::Object</a> *caller, <a class="el" href="classfge_1_1Property.html">fge::Property</a> const &amp;arg, <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *caller_scene)</td></tr>
<tr class="memdesc:a4fb20cb823d38c16aeb7b56f616d6707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a command by its index.  <br /></td></tr>
<tr class="separator:a4fb20cb823d38c16aeb7b56f616d6707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11f8cad16d11f1fb7c83f43cf71ff02" id="r_aa11f8cad16d11f1fb7c83f43cf71ff02"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#aa11f8cad16d11f1fb7c83f43cf71ff02">getCmdIndex</a> (std::string_view name) const</td></tr>
<tr class="memdesc:aa11f8cad16d11f1fb7c83f43cf71ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a command by its name.  <br /></td></tr>
<tr class="separator:aa11f8cad16d11f1fb7c83f43cf71ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d86013df724b960706ae3b2ab1257e" id="r_a43d86013df724b960706ae3b2ab1257e"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a43d86013df724b960706ae3b2ab1257e">getCmdName</a> (std::size_t index) const</td></tr>
<tr class="memdesc:a43d86013df724b960706ae3b2ab1257e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a command by its index.  <br /></td></tr>
<tr class="separator:a43d86013df724b960706ae3b2ab1257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf26dee2a9707b773a93ad0ac11e2a0" id="r_adbf26dee2a9707b773a93ad0ac11e2a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfge_1_1CommandHandler_1_1CommandData.html">fge::CommandHandler::CommandData</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#adbf26dee2a9707b773a93ad0ac11e2a0">getCmd</a> (std::string_view name) const</td></tr>
<tr class="memdesc:adbf26dee2a9707b773a93ad0ac11e2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a command by its name.  <br /></td></tr>
<tr class="separator:adbf26dee2a9707b773a93ad0ac11e2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4885f220ba76549c6bbedd530b7ac723" id="r_a4885f220ba76549c6bbedd530b7ac723"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a4885f220ba76549c6bbedd530b7ac723">getCmdSize</a> () const</td></tr>
<tr class="memdesc:a4885f220ba76549c6bbedd530b7ac723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of commands.  <br /></td></tr>
<tr class="separator:a4885f220ba76549c6bbedd530b7ac723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e238846acb79527c2c9824fa5534667" id="r_a0e238846acb79527c2c9824fa5534667"><td class="memItemLeft" align="right" valign="top">fge::CommandHandler::CommandDataType const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfge_1_1CommandHandler.html#a0e238846acb79527c2c9824fa5534667">getCmdList</a> () const</td></tr>
<tr class="memdesc:a0e238846acb79527c2c9824fa5534667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the commands list.  <br /></td></tr>
<tr class="separator:a0e238846acb79527c2c9824fa5534667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad08489fa18d103b308c7b33a992e639a" id="r_ad08489fa18d103b308c7b33a992e639a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1net_1_1NetworkTypeContainer.html">fge::net::NetworkTypeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad08489fa18d103b308c7b33a992e639a">_netList</a></td></tr>
<tr class="separator:ad08489fa18d103b308c7b33a992e639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60918f884f77c90d94064d2638b676c" id="r_aa60918f884f77c90d94064d2638b676c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1PropertyList.html">fge::PropertyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60918f884f77c90d94064d2638b676c">_properties</a></td></tr>
<tr class="separator:aa60918f884f77c90d94064d2638b676c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef1b051a388cb1e614493140d546f8b" id="r_a4ef1b051a388cb1e614493140d546f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt; <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> const  *, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef1b051a388cb1e614493140d546f8b">_onDraw</a></td></tr>
<tr class="memdesc:a4ef1b051a388cb1e614493140d546f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is about to be drawn.  <br /></td></tr>
<tr class="separator:a4ef1b051a388cb1e614493140d546f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54dec6f8b659e284c76423707bb95b" id="r_afc54dec6f8b659e284c76423707bb95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt; <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *, fge::ObjectDataShared const  &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc54dec6f8b659e284c76423707bb95b">_onObjectAdded</a></td></tr>
<tr class="memdesc:afc54dec6f8b659e284c76423707bb95b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> has been added.  <br /></td></tr>
<tr class="separator:afc54dec6f8b659e284c76423707bb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e57f18a5e1f606a69a9a8931f7250" id="r_ad94e57f18a5e1f606a69a9a8931f7250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt; <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *, fge::ObjectDataShared const  &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94e57f18a5e1f606a69a9a8931f7250">_onObjectRemoved</a></td></tr>
<tr class="memdesc:ad94e57f18a5e1f606a69a9a8931f7250"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> has been removed.  <br /></td></tr>
<tr class="separator:ad94e57f18a5e1f606a69a9a8931f7250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ac8e8febbbde5ca7778a39edfa9848" id="r_a37ac8e8febbbde5ca7778a39edfa9848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt; <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *, fge::ObjectPlan &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37ac8e8febbbde5ca7778a39edfa9848">_onPlanUpdate</a></td></tr>
<tr class="memdesc:a37ac8e8febbbde5ca7778a39edfa9848"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when a change in the plan is detected.  <br /></td></tr>
<tr class="separator:a37ac8e8febbbde5ca7778a39edfa9848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3607c8eb643375226efb428857d9f272" id="r_a3607c8eb643375226efb428857d9f272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt; <a class="el" href="classfge_1_1Scene.html">fge::Scene</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3607c8eb643375226efb428857d9f272">_onDelayedUpdate</a></td></tr>
<tr class="memdesc:a3607c8eb643375226efb428857d9f272"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called only once after a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> update.  <br /></td></tr>
<tr class="separator:a3607c8eb643375226efb428857d9f272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A scene contain a collection of object and handle them. </p>
<p>The job of a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is to hande a collection of <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> and implement some utility method for the user to control them.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a942e9634cf7838f1266bf782627472" name="a7a942e9634cf7838f1266bf782627472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a942e9634cf7838f1266bf782627472">&#9670;&#160;</a></span>addCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::CommandHandler::addCmd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1CommandHandler.html">fge::CommandHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::CommandFunction</td>          <td class="paramname"><span class="paramname"><em>cmdfunc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new command to the handler. </p>
<p>An object should inherit from <a class="el" href="classfge_1_1CommandHandler.html" title="CommandHandler is a class that can be used to handle commands.">CommandHandler</a> and add commands to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
    <tr><td class="paramname">handle</td><td>The object that will handle the command </td></tr>
    <tr><td class="paramname">cmdfunc</td><td>The function pointer of the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the command was added, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="a4fb20cb823d38c16aeb7b56f616d6707" name="a4fb20cb823d38c16aeb7b56f616d6707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb20cb823d38c16aeb7b56f616d6707">&#9670;&#160;</a></span>callCmd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1Property.html">fge::Property</a> fge::CommandHandler::callCmd </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Object.html">fge::Object</a> *</td>          <td class="paramname"><span class="paramname"><em>caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Property.html">fge::Property</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *</td>          <td class="paramname"><span class="paramname"><em>caller_scene</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a command by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the command </td></tr>
    <tr><td class="paramname">caller</td><td>The object that call the command </td></tr>
    <tr><td class="paramname">arg</td><td>The arguments of the command </td></tr>
    <tr><td class="paramname">caller_scene</td><td>The scene that contains the caller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classfge_1_1Property.html" title="A class that can store any type of data.">Property</a> containing the result of the command </dd></dl>

</div>
</div>
<a id="aca7bd7cbf1c44a040520a67b9cbf1663" name="aca7bd7cbf1c44a040520a67b9cbf1663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7bd7cbf1c44a040520a67b9cbf1663">&#9670;&#160;</a></span>callCmd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1Property.html">fge::Property</a> fge::CommandHandler::callCmd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Object.html">fge::Object</a> *</td>          <td class="paramname"><span class="paramname"><em>caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Property.html">fge::Property</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Scene.html">fge::Scene</a> *</td>          <td class="paramname"><span class="paramname"><em>caller_scene</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a command by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
    <tr><td class="paramname">caller</td><td>The object that call the command </td></tr>
    <tr><td class="paramname">arg</td><td>The arguments of the command </td></tr>
    <tr><td class="paramname">caller_scene</td><td>The scene that contains the caller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classfge_1_1Property.html" title="A class that can store any type of data.">Property</a> containing the result of the command </dd></dl>

</div>
</div>
<a id="a134b3edd8f27787fe0a34cd8a58212bc" name="a134b3edd8f27787fe0a34cd8a58212bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134b3edd8f27787fe0a34cd8a58212bc">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This method call :</p><ul>
<li>delAllObject including GUI <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> type.</li>
<li>PropertyList::delAllProperties.</li>
<li>fge::net::NetworkTypeContainer::clear. </li>
</ul>

</div>
</div>
<a id="a9063fb43f0180049875bedad48c7eb3d" name="a9063fb43f0180049875bedad48c7eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9063fb43f0180049875bedad48c7eb3d">&#9670;&#160;</a></span>clearCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fge::CommandHandler::clearCmd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all commands from the handler. </p>

</div>
</div>
<a id="afe195957097d419c3aa8d2f0db4c2970" name="afe195957097d419c3aa8d2f0db4c2970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe195957097d419c3aa8d2f0db4c2970">&#9670;&#160;</a></span>clearNetEventsQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::clearNetEventsQueue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> network events queue for all clients. </p>

</div>
</div>
<a id="a24d887de08c9aba5cc5b75fbe909fb7b" name="a24d887de08c9aba5cc5b75fbe909fb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d887de08c9aba5cc5b75fbe909fb7b">&#9670;&#160;</a></span>clearNetEventsQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::clearNetEventsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> network events queue for the specified client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7af9d63957efe689f35410b06c998954" name="a7af9d63957efe689f35410b06c998954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af9d63957efe689f35410b06c998954">&#9670;&#160;</a></span>clearPerClientSyncData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::clearPerClientSyncData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all network clients related data. </p>
<p>After a call to this function, you have to recall clientsCheckupEvent to re-register clients. </p>

</div>
</div>
<a id="a593365c0a07e25a62350d44928610780" name="a593365c0a07e25a62350d44928610780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593365c0a07e25a62350d44928610780">&#9670;&#160;</a></span>clientsCheckup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::clientsCheckup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1ClientList.html">fge::net::ClientList</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>clients</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>force</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a clients checkup. </p>
<p>A clients checkup is necessary to keep an eye of new/removal client and keep a modification flag for every one of them.</p>
<p>Clients latency will vary a lot, so to keep an eye of what partial <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> modification have to be sent, a clients checkup is required.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1net_1_1NetworkTypeBase.html#a4001776bda7672c5722ec41bc5955da2" title="Do a clients checkup with the specified client list.">net::NetworkTypeBase::clientsCheckup</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clients</td><td>The <a class="el" href="classfge_1_1net_1_1ClientList.html" title="A list of clients used by a server.">net::ClientList</a> attributed to this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> </td></tr>
    <tr><td class="paramname">force</td><td>If <b>true</b>, all per clients data will clear and redo a full checkup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd52b6a9ba0b39f4e66114e1abf37c2" name="a5fd52b6a9ba0b39f4e66114e1abf37c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd52b6a9ba0b39f4e66114e1abf37c2">&#9670;&#160;</a></span>delAllObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::delAllObject </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreGuiObject</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignoreGuiObject</td><td>If <b>true</b>, every GUI type <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> is not deleted by this method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of deleted <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </dd></dl>

</div>
</div>
<a id="a044f3a48f1b43087bf5473a933c76513" name="a044f3a48f1b43087bf5473a933c76513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044f3a48f1b43087bf5473a933c76513">&#9670;&#160;</a></span>delCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fge::CommandHandler::delCmd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a command from the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1843d797109901ad654b3687691bd6e3" name="a1843d797109901ad654b3687691bd6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1843d797109901ad654b3687691bd6e3">&#9670;&#160;</a></span>delCustomView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::delCustomView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the actual custom view. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c" title="Set a custom shared view.">setCustomView</a> </dd></dl>

</div>
</div>
<a id="a6058721874450172e3b8c0dfe5ef793a" name="a6058721874450172e3b8c0dfe5ef793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6058721874450172e3b8c0dfe5ef793a">&#9670;&#160;</a></span>delObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::delObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> provided with his SID. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method should not be called in the updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> for deleting itself</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac3b92bf6ebe18b65e05548e14bd22798" title="Delete the actual updated Object.">delUpdatedObject</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> is correctly deleted or <b>false</b> if the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> is not found </dd></dl>

</div>
</div>
<a id="ac3b92bf6ebe18b65e05548e14bd22798" name="ac3b92bf6ebe18b65e05548e14bd22798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b92bf6ebe18b65e05548e14bd22798">&#9670;&#160;</a></span>delUpdatedObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::delUpdatedObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the actual updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>. </p>
<p>This method mark the actual <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to be deleted internally. When the actual <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> has finished is update, the <a class="el" href="#a4b1bca7b135815669dba730aab11f61d" title="Update of the Scene.">update()</a> method correctly delete it.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is not meant to be used outside of an update and will cause weird behaviour if not respected. (like deleting the first updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b1bca7b135815669dba730aab11f61d" title="Update of the Scene.">update</a> </dd></dl>

</div>
</div>
<a id="a81a158566c6cb15351ad5957809fac14" name="a81a158566c6cb15351ad5957809fac14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a158566c6cb15351ad5957809fac14">&#9670;&#160;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderStates.html">fge::RenderStates</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This method call the <a class="el" href="classfge_1_1Object.html#a11f9cc4ffa3e2881475bb475c1632422" title="Method called every frame to draw the object.">Object::draw</a> method of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the scene.</p>
<p>The scene will draw an object according to it's <a class="el" href="classfge_1_1Object.html#adf5a9a1ae1be023ba3efc58646aaa8e1" title="Tell a scene when this object should be drawn.">Object::_drawMode</a> : By default, the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> check if the global bounds of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> is in the bounds of the screen and draw it if it's there.</p>
<p>This behaviour can be surpassed by setting <a class="el" href="classfge_1_1Object.html#adf5a9a1ae1be023ba3efc58646aaa8e1" title="Tell a scene when this object should be drawn.">Object::_drawMode</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1Object.html#a849d36f905682fedd870d96fb2d5c81c" title="Get the global bounds of the object.">Object::getGlobalBounds</a></dd></dl>
<p>During the draw, the depth plan is re-assigned depending of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> plan and position in the list. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1ObjectData.html#a8461161364b97172d4e9c1993a78625d" title="Get the plan depth of the Object.">ObjectData::getPlanDepth</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
    <tr><td class="paramname">states</td><td>The default <a class="el" href="classfge_1_1RenderStates.html" title="The RenderStates class contains all the information needed to render something.">RenderStates</a> to be used for every drawn <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b67037f9d1674d42139454ee0dd56f4" name="a2b67037f9d1674d42139454ee0dd56f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b67037f9d1674d42139454ee0dd56f4">&#9670;&#160;</a></span>duplicateObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::duplicateObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>newSid</em><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;fge::ObjectSid&#160;&gt;::max()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the provided <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> SID. </p>
<p>This method duplicate the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> corresponding to the provided SID by giving an new SID to the freshly duplicated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>.</p>
<p>This method call the <a class="el" href="classfge_1_1Object.html#a21fc497a76f297207f92a54523cb0a0c" title="Duplicate the object.">Object::copy</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to be duplicated </td></tr>
    <tr><td class="paramname">newSid</td><td>The new SID of the duplicated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An shared pointer of the new <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="ab83edebc0be083c1fe2d59bd9ab2c454" name="ab83edebc0be083c1fe2d59bd9ab2c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83edebc0be083c1fe2d59bd9ab2c454">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectContainer::const_iterator fge::Scene::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Object.html">fge::Object</a> const *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator representing the <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="a9a6cfc624390613d0775d9b4e4d9b48b" name="a9a6cfc624390613d0775d9b4e4d9b48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6cfc624390613d0775d9b4e4d9b48b">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectContainer::const_iterator fge::Scene::find </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified SID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> SID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator representing the <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="a76b6add901c3904ea3c540e2d4bc2b0f" name="a76b6add901c3904ea3c540e2d4bc2b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b6add901c3904ea3c540e2d4bc2b0f">&#9670;&#160;</a></span>findPlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectContainer::const_iterator fge::Scene::findPlan </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectPlan</td>          <td class="paramname"><span class="paramname"><em>plan</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the specified plan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator representing the <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="a332d7d2840f94482eed5e277f65df50a" name="a332d7d2840f94482eed5e277f65df50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332d7d2840f94482eed5e277f65df50a">&#9670;&#160;</a></span>forceCheckClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::forceCheckClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force every network type modification flag to be <b>true</b> for a specified client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a>. </p>
<p>When a modification flag is <b>true</b> for a <a class="el" href="classfge_1_1net_1_1NetworkType.html" title="The default network type for most trivial types.">net::NetworkType</a>, every data affected will be packed in the next call of packModification</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a463bf3908788d7eb036ee489bc22f906" name="a463bf3908788d7eb036ee489bc22f906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463bf3908788d7eb036ee489bc22f906">&#9670;&#160;</a></span>forceUncheckClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::forceUncheckClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force every network type modification flag to be <b>false</b> for a specified client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a332d7d2840f94482eed5e277f65df50a" title="Force every network type modification flag to be true for a specified client net::Identity.">forceCheckClient</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe590c8fc034b6435c1c83c8c484be08" name="abe590c8fc034b6435c1c83c8c484be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe590c8fc034b6435c1c83c8c484be08">&#9670;&#160;</a></span>generateSid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual fge::ObjectSid fge::Scene::generateSid </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>wanted_sid</em><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;fge::ObjectSid&#160;&gt;::max()</span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an SID based on the provided wanted SID. </p>
<p>By default, if the wanted SID is FGE_SCENE_BAD_SID, this function try to generate one with random value using <a class="el" href="group__utility.html#ga9d5ebe4d592b8634d5ef5b6843298ae3" title="Default random number generator instance.">fge::_random</a>.</p>
<p>If the wanted SID is already taken, this will cause an random SID generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wanted_sid</td><td>The wanted SID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The SID generated </dd></dl>

</div>
</div>
<a id="a60a093fdda11e644a295f4dfbed2086e" name="a60a093fdda11e644a295f4dfbed2086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a093fdda11e644a295f4dfbed2086e">&#9670;&#160;</a></span>getAllObj_ByClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByClass </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>class_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the same class name. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1Object.html#a5802633d7b1349343187a4d26f553939" title="Get the unique class name of the object.">Object::getClassName</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The wanted class name </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="a94038fe5a510f75997f9a7adadf051a9" name="a94038fe5a510f75997f9a7adadf051a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94038fe5a510f75997f9a7adadf051a9">&#9670;&#160;</a></span>getAllObj_ByLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByLocalPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2i const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position. </p>
<p>This function first convert the local position to global coordinate with the <b>custom</b> <b>view</b> of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> if there is one. Then it check if the global bounds of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> contain the provided position.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c" title="Set a custom shared view.">setCustomView</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The local position </td></tr>
    <tr><td class="paramname">target</td><td>An <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="aba3de1ea78b412310c23385e15da556d" name="aba3de1ea78b412310c23385e15da556d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3de1ea78b412310c23385e15da556d">&#9670;&#160;</a></span>getAllObj_ByLocalZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByLocalZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone (or rectangle). </p>
<p>This function first convert the local zone to global coordinate with the <b>custom</b> <b>view</b> of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> if there is one. Then it check if the global bounds of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> intersect with the provided zone (or rectangle).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The local zone </td></tr>
    <tr><td class="paramname">target</td><td>An <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="afcb6eb4893954842a1915e8d7fc3c718" name="afcb6eb4893954842a1915e8d7fc3c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb6eb4893954842a1915e8d7fc3c718">&#9670;&#160;</a></span>getAllObj_ByPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2f const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a position. </p>
<p>This function check if the global bounds of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> contain the provided position.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="aedb3405d407179102a4df8d0f9e17e45" name="aedb3405d407179102a4df8d0f9e17e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb3405d407179102a4df8d0f9e17e45">&#9670;&#160;</a></span>getAllObj_ByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByTag </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>tag_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that contain the provided tag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfge_1_1TagList.html">TagList</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_name</td><td>The wanted tag </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="a3c82022744dd4de6a84cb6d364de42d6" name="a3c82022744dd4de6a84cb6d364de42d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c82022744dd4de6a84cb6d364de42d6">&#9670;&#160;</a></span>getAllObj_ByZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_ByZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectFloat</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a zone (or rectangle). </p>
<p>This function check if the global bounds of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> intersect with the provided zone (or rectangle).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The zone </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="ab4741a3f3d76efcba519a1704d60cc3d" name="ab4741a3f3d76efcba519a1704d60cc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4741a3f3d76efcba519a1704d60cc3d">&#9670;&#160;</a></span>getAllObj_FromLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_FromLocalPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2i const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position. </p>
<p>Instead of converting the provided local position to global coordinate, this function convert the global bounds of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to local coordinate and check if converted local bounds contain the provided position.</p>
<p>This function will use the <b>custom</b> <b>view</b> of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> if there is one.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c" title="Set a custom shared view.">setCustomView</a> <a class="el" href="#a94038fe5a510f75997f9a7adadf051a9" title="Get all Object with a local position.">getAllObj_ByLocalPosition</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The local position </td></tr>
    <tr><td class="paramname">target</td><td>An <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="a8e40feb16e3f09349433258f293e687c" name="a8e40feb16e3f09349433258f293e687c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e40feb16e3f09349433258f293e687c">&#9670;&#160;</a></span>getAllObj_FromLocalZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getAllObj_FromLocalZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectContainer &amp;</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone (or rectangle). </p>
<p>Instead of converting the provided local zone to global coordinate, this function convert the global bounds of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to local coordinate and check if the converted local bounds intersect with the provided zone.</p>
<p>This function will use the <b>custom</b> <b>view</b> of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> if there is one.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c" title="Set a custom shared view.">setCustomView</a> <a class="el" href="#aba3de1ea78b412310c23385e15da556d" title="Get all Object within a local zone (or rectangle).">getAllObj_ByLocalZone</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function do not clear data in the ObjectContainer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The local zone </td></tr>
    <tr><td class="paramname">target</td><td>An <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
    <tr><td class="paramname">buff</td><td>An ObjectContainer that will receive results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of Objects added in the container </dd></dl>

</div>
</div>
<a id="a2b70e4aa277e8a0a200322291250c234" name="a2b70e4aa277e8a0a200322291250c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b70e4aa277e8a0a200322291250c234">&#9670;&#160;</a></span>getCallbackContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfge_1_1CallbackContext.html">fge::CallbackContext</a> fge::Scene::getCallbackContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the callback context of this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9f910bebd40741e4714be2e54cf98f11" title="Set the callback context of this Scene.">setCallbackContext</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The callback context </dd></dl>

</div>
</div>
<a id="adbf26dee2a9707b773a93ad0ac11e2a0" name="adbf26dee2a9707b773a93ad0ac11e2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf26dee2a9707b773a93ad0ac11e2a0">&#9670;&#160;</a></span>getCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfge_1_1CommandHandler_1_1CommandData.html">fge::CommandHandler::CommandData</a> const  * fge::CommandHandler::getCmd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a command by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The command or nullptr if the command doesn't exist </dd></dl>

</div>
</div>
<a id="aa11f8cad16d11f1fb7c83f43cf71ff02" name="aa11f8cad16d11f1fb7c83f43cf71ff02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11f8cad16d11f1fb7c83f43cf71ff02">&#9670;&#160;</a></span>getCmdIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::CommandHandler::getCmdIndex </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of a command by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the command or std::numeric_limits&lt;std::size_t&gt;::max() if the command doesn't exist </dd></dl>

</div>
</div>
<a id="a0e238846acb79527c2c9824fa5534667" name="a0e238846acb79527c2c9824fa5534667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e238846acb79527c2c9824fa5534667">&#9670;&#160;</a></span>getCmdList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fge::CommandHandler::CommandDataType const  &amp; fge::CommandHandler::getCmdList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the commands list. </p>
<dl class="section return"><dt>Returns</dt><dd>The commands list </dd></dl>

</div>
</div>
<a id="a43d86013df724b960706ae3b2ab1257e" name="a43d86013df724b960706ae3b2ab1257e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d86013df724b960706ae3b2ab1257e">&#9670;&#160;</a></span>getCmdName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view fge::CommandHandler::getCmdName </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of a command by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the command or an empty string if the command doesn't exist </dd></dl>

</div>
</div>
<a id="a4885f220ba76549c6bbedd530b7ac723" name="a4885f220ba76549c6bbedd530b7ac723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4885f220ba76549c6bbedd530b7ac723">&#9670;&#160;</a></span>getCmdSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::CommandHandler::getCmdSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of commands. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of commands </dd></dl>

</div>
</div>
<a id="a78477cb4efccfe5adbd54de8eee3079e" name="a78477cb4efccfe5adbd54de8eee3079e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78477cb4efccfe5adbd54de8eee3079e">&#9670;&#160;</a></span>getCustomView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classfge_1_1View.html">fge::View</a> &gt; const  &amp; fge::Scene::getCustomView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the custom shared view if there is one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad802b973a26fb69a7925ec0fb1b0b62c" title="Set a custom shared view.">setCustomView</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The shared point of the view </dd></dl>

</div>
</div>
<a id="a2e0f40001a17fa427e7fa09e17b8e240" name="a2e0f40001a17fa427e7fa09e17b8e240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0f40001a17fa427e7fa09e17b8e240">&#9670;&#160;</a></span>getFirstObj_ByClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByClass </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match a provided class name. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a60a093fdda11e644a295f4dfbed2086e" title="Get all Object with the same class name.">getAllObj_ByClass</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The class name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="af5a87ee6b21e6b7c7c77c22304eae36b" name="af5a87ee6b21e6b7c7c77c22304eae36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a87ee6b21e6b7c7c77c22304eae36b">&#9670;&#160;</a></span>getFirstObj_ByLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByLocalPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2i const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94038fe5a510f75997f9a7adadf051a9" title="Get all Object with a local position.">getAllObj_ByLocalPosition</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The local position </td></tr>
    <tr><td class="paramname">target</td><td>The <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="a3693d8c66e93813270c877b17fbf9e4c" name="a3693d8c66e93813270c877b17fbf9e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3693d8c66e93813270c877b17fbf9e4c">&#9670;&#160;</a></span>getFirstObj_ByLocalZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByLocalZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aba3de1ea78b412310c23385e15da556d" title="Get all Object within a local zone (or rectangle).">getAllObj_ByLocalZone</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The local zone </td></tr>
    <tr><td class="paramname">target</td><td>The <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="a27288a15502249dcdb32ed04f616c466" name="a27288a15502249dcdb32ed04f616c466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27288a15502249dcdb32ed04f616c466">&#9670;&#160;</a></span>getFirstObj_ByPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2f const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a position. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afcb6eb4893954842a1915e8d7fc3c718" title="Get all Object with a position.">getAllObj_ByPosition</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="abb518824319d6faab3c0245926978dbd" name="abb518824319d6faab3c0245926978dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb518824319d6faab3c0245926978dbd">&#9670;&#160;</a></span>getFirstObj_ByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByTag </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>tag_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match a provided tag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aedb3405d407179102a4df8d0f9e17e45" title="Get all Object that contain the provided tag.">getAllObj_ByTag</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_name</td><td>The tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="aa84d0774b945b905ba41d254b0bb1dcf" name="aa84d0774b945b905ba41d254b0bb1dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84d0774b945b905ba41d254b0bb1dcf">&#9670;&#160;</a></span>getFirstObj_ByZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_ByZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectFloat</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a zone. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3c82022744dd4de6a84cb6d364de42d6" title="Get all Object within a zone (or rectangle).">getAllObj_ByZone</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The zone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="abd3099db3370212a5a384b22cd413676" name="abd3099db3370212a5a384b22cd413676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3099db3370212a5a384b22cd413676">&#9670;&#160;</a></span>getFirstObj_FromLocalPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_FromLocalPosition </td>
          <td>(</td>
          <td class="paramtype">fge::Vector2i const &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a local position position. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab4741a3f3d76efcba519a1704d60cc3d" title="Get all Object with a local position.">getAllObj_FromLocalPosition</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position </td></tr>
    <tr><td class="paramname">target</td><td>The <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="a43eed46196c9c4cb1e37c431fda86e57" name="a43eed46196c9c4cb1e37c431fda86e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eed46196c9c4cb1e37c431fda86e57">&#9670;&#160;</a></span>getFirstObj_FromLocalZone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getFirstObj_FromLocalZone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Rect.html">fge::RectInt</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>zone</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> within a local zone. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8e40feb16e3f09349433258f293e687c" title="Get all Object within a local zone (or rectangle).">getAllObj_FromLocalZone</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>The local zone </td></tr>
    <tr><td class="paramname">target</td><td>The <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that match the argument </dd></dl>

</div>
</div>
<a id="a51411ea28b16b80eb703ce31117311d3" name="a51411ea28b16b80eb703ce31117311d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51411ea28b16b80eb703ce31117311d3">&#9670;&#160;</a></span>getLinkedRenderTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> * fge::Scene::getLinkedRenderTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> linked to this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> (non-const). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a951584bafb9b1bc616e0377209ef5317" title="Link a RenderTarget to the Scene.">setLinkedRenderTarget</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The linked <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> or <b>nullptr</b> if there is none </dd></dl>

</div>
</div>
<a id="a96dce198c7b3507c54ecab506fe10d2b" name="a96dce198c7b3507c54ecab506fe10d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dce198c7b3507c54ecab506fe10d2b">&#9670;&#160;</a></span>getLinkedRenderTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> const  * fge::Scene::getLinkedRenderTarget </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> linked to this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a951584bafb9b1bc616e0377209ef5317" title="Link a RenderTarget to the Scene.">setLinkedRenderTarget</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The linked <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> or <b>nullptr</b> if there is none </dd></dl>

</div>
</div>
<a id="ae51b387a37caf9e539021120bcfe937e" name="ae51b387a37caf9e539021120bcfe937e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51b387a37caf9e539021120bcfe937e">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const  &amp; fge::Scene::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> </dd></dl>

</div>
</div>
<a id="af1883edecf98c70f9eb914f3e3e8313a" name="af1883edecf98c70f9eb914f3e3e8313a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1883edecf98c70f9eb914f3e3e8313a">&#9670;&#160;</a></span>getObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Object.html">fge::Object</a> const *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with his pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Actual pointer of the wanted <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shared <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> pointer </dd></dl>

</div>
</div>
<a id="a858d56bc173593923b10f14de42d2acc" name="a858d56bc173593923b10f14de42d2acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858d56bc173593923b10f14de42d2acc">&#9670;&#160;</a></span>getObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with his SID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the wanted <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shared <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> pointer </dd></dl>

</div>
</div>
<a id="a2e66f063fd2f32e840e927e6e1c13d1b" name="a2e66f063fd2f32e840e927e6e1c13d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66f063fd2f32e840e927e6e1c13d1b">&#9670;&#160;</a></span>getObjectPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1Object.html">fge::Object</a> * fge::Scene::getObjectPtr </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer with his SID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the wanted <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer </dd></dl>

</div>
</div>
<a id="a379d5833cca1706dd800b2b0a779443c" name="a379d5833cca1706dd800b2b0a779443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379d5833cca1706dd800b2b0a779443c">&#9670;&#160;</a></span>getObjectSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t fge::Scene::getObjectSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> stored in this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </dd></dl>

</div>
</div>
<a id="a9f2403036e442020c2e0d590da8a2dbe" name="a9f2403036e442020c2e0d590da8a2dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2403036e442020c2e0d590da8a2dbe">&#9670;&#160;</a></span>getRelatedView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1View.html">fge::View</a> const  * fge::Scene::getRelatedView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the related view of the scene. </p>
<p>If the scene have a custom view set, the custom view is returned. Else if the scene have a linked render target, the view of this render target is returned.</p>
<p>Else return <b>nullptr</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>The related view pointer or <b>nullptr</b> if there is none </dd></dl>

</div>
</div>
<a id="a3be180b9ffe8970e3908063b282c4f58" name="a3be180b9ffe8970e3908063b282c4f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be180b9ffe8970e3908063b282c4f58">&#9670;&#160;</a></span>getSid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectSid fge::Scene::getSid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1Object.html">fge::Object</a> const *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SID of the provided <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FGE_SCENE_BAD_SID if there is no match, the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> SID otherwise </dd></dl>

</div>
</div>
<a id="a2361734d3daa31588ee75b5b5531052b" name="a2361734d3daa31588ee75b5b5531052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2361734d3daa31588ee75b5b5531052b">&#9670;&#160;</a></span>getUpdateCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fge::Scene::getUpdateCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of update. </p>
<p>In order to increment the update count, the UpdateFlags::INCREMENT_UPDATE_COUNT flag must be used while calling the update method.</p>
<p>This flag is generally set by the server.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of update </dd></dl>

</div>
</div>
<a id="af570e03e4071aa8b8d187b9784ecec48" name="af570e03e4071aa8b8d187b9784ecec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af570e03e4071aa8b8d187b9784ecec48">&#9670;&#160;</a></span>getUpdatedObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::getUpdatedObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The shared <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> pointer </dd></dl>

</div>
</div>
<a id="a925832b373e45368c78c642829a8d615" name="a925832b373e45368c78c642829a8d615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925832b373e45368c78c642829a8d615">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::isValid </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the SID correspond to an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> SID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the SID correspond </dd></dl>

</div>
</div>
<a id="a17b1a24eff38a6bad8e942ebd84e0f7e" name="a17b1a24eff38a6bad8e942ebd84e0f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b1a24eff38a6bad8e942ebd84e0f7e">&#9670;&#160;</a></span>isWatchingEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::isWatchingEvent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is currently watching events. ". </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae238766ad9a6fddfcec948bfe3d1e2e1" title="Start to watch Scene related event or not.">watchEvent</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Watch <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> events stats </dd></dl>

</div>
</div>
<a id="a6029e8c9aea4e5cc2a94603bcbaefa10" name="a6029e8c9aea4e5cc2a94603bcbaefa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6029e8c9aea4e5cc2a94603bcbaefa10">&#9670;&#160;</a></span>loadCustomData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fge::Scene::loadCustomData </td>
          <td>(</td>
          <td class="paramtype">nlohmann::json &amp;</td>          <td class="paramname"><span class="paramname"><em>jsonObject</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load some user defined custom data. </p>
<p>This function doesn't do anything by default but can be override to load some data during a loadFromFile call.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2355bd9912b4ed5b1fd7707a046cfcea" title="Load all the Scene data from a json file.">loadFromFile</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonObject</td><td>The json object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2355bd9912b4ed5b1fd7707a046cfcea" name="a2355bd9912b4ed5b1fd7707a046cfcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2355bd9912b4ed5b1fd7707a046cfcea">&#9670;&#160;</a></span>loadFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data from a json file. </p>
<p>This function load all the data from a json format.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function clear everything in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> before the file loading.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6edde93a552e2e2d449596331f8d728" title="Save all the Scene with its Object in a file.">saveInFile</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if successful, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="af590bed5f9b9cbc4b80f839da1c2b3fa" name="af590bed5f9b9cbc4b80f839da1c2b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af590bed5f9b9cbc4b80f839da1c2b3fa">&#9670;&#160;</a></span>newObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::newObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectDataShared const &amp;</td>          <td class="paramname"><span class="paramname"><em>objectData</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>silent</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This method add already handled shared <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. The linked <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is automatically set to the target <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The provided <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> must have a valid <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer.</dd></dl>
<p>If the object is created inside the <a class="el" href="#a4b1bca7b135815669dba730aab11f61d" title="Update of the Scene.">update()</a> method from a second object, the second object become parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectData</td><td>The shared <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </td></tr>
    <tr><td class="paramname">silent</td><td>If <b>true</b>, the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> will not call the <a class="el" href="classfge_1_1Object.html#a84cd084ae66696cf0f33f0c3e1f68cf1" title="Method called when the object is added to a scene for initialization purposes.">Object::first</a> or <a class="el" href="classfge_1_1Object.html#ae9f531a05d43d09501849905d1e2f00c" title="Ask the object to register all callbacks it needs to receive events.">Object::callbackRegister</a> methods </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An shared pointer of the <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="a9ccfa1288c2909a7b1e9bea3c4ae12cd" name="a9ccfa1288c2909a7b1e9bea3c4ae12cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccfa1288c2909a7b1e9bea3c4ae12cd">&#9670;&#160;</a></span>newObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::newObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectPtr &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>newObject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectPlan</td>          <td class="paramname"><span class="paramname"><em>plan</em><span class="paramdefsep"> = </span><span class="paramdefval">fge::ObjectPlan&#160;{&#160;100&#160;}</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;fge::ObjectSid&#160;&gt;::max()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__objectControl.html#ga6d371b22ba3b898839c934bd4501c284">fge::ObjectType</a></td>          <td class="paramname"><span class="paramname"><em>type</em><span class="paramdefsep"> = </span><span class="paramdefval">fge::ObjectType::TYPE_OBJECT</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>silent</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This method add a created <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. The provided SID is passed to the virtual <a class="el" href="#abe590c8fc034b6435c1c83c8c484be08" title="Generate an SID based on the provided wanted SID.">generateSid()</a> method.</p>
<dl class="section warning"><dt>Warning</dt><dd>The provided pointer of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>, have to be allocated in the <b>heap</b> and must not be handled by the user.</dd>
<dd>
If there is an error during the addition of the new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>, the returned shared pointer is not valid and the provided <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> is dismissed.</dd></dl>
<p>If the object is created inside the <a class="el" href="#a4b1bca7b135815669dba730aab11f61d" title="Update of the Scene.">update()</a> method from a second object, the second object become parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newObject</td><td>The object pointer allocated by the user </td></tr>
    <tr><td class="paramname">plan</td><td>The plan of the new object </td></tr>
    <tr><td class="paramname">sid</td><td>The wanted SID </td></tr>
    <tr><td class="paramname">type</td><td>The type of the new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
    <tr><td class="paramname">silent</td><td>If <b>true</b>, the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> will not call the <a class="el" href="classfge_1_1Object.html#a84cd084ae66696cf0f33f0c3e1f68cf1" title="Method called when the object is added to a scene for initialization purposes.">Object::first</a> or <a class="el" href="classfge_1_1Object.html#ae9f531a05d43d09501849905d1e2f00c" title="Ask the object to register all callbacks it needs to receive events.">Object::callbackRegister</a> methods </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An shared pointer of the <a class="el" href="classfge_1_1ObjectData.html" title="Data wrapper representing an Object in a Scene.">ObjectData</a> </dd></dl>

</div>
</div>
<a id="a76a9e75a5e156fe96f28e3180f3cff7d" name="a76a9e75a5e156fe96f28e3180f3cff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a9e75a5e156fe96f28e3180f3cff7d">&#9670;&#160;</a></span>pack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data in a Packet. </p>
<p>This function is useful to do a full <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> synchronisation in a network from a server.</p>
<dl class="section warning"><dt>Warning</dt><dd>The maximum <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that can be packed is fge::net::SizeType.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98deb4840dd20aea4d4e9a1a5cd7303" name="ac98deb4840dd20aea4d4e9a1a5cd7303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98deb4840dd20aea4d4e9a1a5cd7303">&#9670;&#160;</a></span>pack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data in a Packet for a <a class="el" href="classfge_1_1net_1_1Client.html" title="Class that represent the identity of a client.">net::Client</a>. </p>
<p>This function is useful to do a full <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> synchronisation in a network from a server. By providing a <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a>, the function will initialise/reset some internal sync stats like update count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
    <tr><td class="paramname">id</td><td>The Identity of the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c93e6fbc04ac4be98bb7951e06760f1" name="a7c93e6fbc04ac4be98bb7951e06760f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c93e6fbc04ac4be98bb7951e06760f1">&#9670;&#160;</a></span>packModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::packModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack all modification in a <a class="el" href="classfge_1_1net_1_1Packet.html">net::Packet</a> for a <a class="el" href="classfge_1_1net_1_1Client.html" title="Class that represent the identity of a client.">net::Client</a>. </p>
<p>The scene check for variable modification, the new value is then packed in the network <a class="el" href="classfge_1_1net_1_1Packet.html">net::Packet</a>, with some basic <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> information like the SID.</p>
<p>This allow a partial synchronisation between multiple clients and a server. A partial sync is here to avoid re-sending over and over the same or a bit modified full <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> data. If you have a lots of <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>, this can be helpful for Packet size and bandwidth.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a593365c0a07e25a62350d44928610780" title="Do a clients checkup.">clientsCheckup</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The maximum <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that can be packed is fge::net::SizeType.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
    <tr><td class="paramname">id</td><td>The Identity of the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca7aee65c2b9df82f7cdef1ec6eb8f1" name="a7ca7aee65c2b9df82f7cdef1ec6eb8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca7aee65c2b9df82f7cdef1ec6eb8f1">&#9670;&#160;</a></span>packNeededUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::packNeededUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack object that need an explicit update from the server. </p>
<p>This should be called by a client to ask the server for specific network value update.</p>
<dl class="section see"><dt>See also</dt><dd>NetworkTypeContainer::packNeededUpdate</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabe509b2955a18efde8fdac65a12d80d" name="aabe509b2955a18efde8fdac65a12d80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe509b2955a18efde8fdac65a12d80d">&#9670;&#160;</a></span>packWatchedEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::packWatchedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack all <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related events for a specified client. </p>
<p>After a call to this function, the event queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
    <tr><td class="paramname">id</td><td>The client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37b60110653eb4c1d878fa815dd98bc" name="ac37b60110653eb4c1d878fa815dd98bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37b60110653eb4c1d878fa815dd98bc">&#9670;&#160;</a></span>pushEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::pushEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1SceneNetEvent.html">fge::SceneNetEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>netEvent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually push a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event for every clients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netEvent</td><td>The <a class="el" href="structfge_1_1SceneNetEvent.html" title="Structure that represent an network event related to Scene.">SceneNetEvent</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31a8f36085235ebfb900a4d66abb11ce" name="a31a8f36085235ebfb900a4d66abb11ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a8f36085235ebfb900a4d66abb11ce">&#9670;&#160;</a></span>pushEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::pushEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1SceneNetEvent.html">fge::SceneNetEvent</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>netEvent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually push a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event for a specified client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">netEvent</td><td>The <a class="el" href="structfge_1_1SceneNetEvent.html" title="Structure that represent an network event related to Scene.">SceneNetEvent</a> </td></tr>
    <tr><td class="paramname">id</td><td>A client <a class="el" href="structfge_1_1net_1_1Identity.html" title="A class to represent a client or server identity with an IP address and a port.">net::Identity</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa06c716d59048bbd8bc4398685b3f3a1" name="aa06c716d59048bbd8bc4398685b3f3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06c716d59048bbd8bc4398685b3f3a1">&#9670;&#160;</a></span>replaceCmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::CommandHandler::replaceCmd </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1CommandHandler.html">fge::CommandHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::CommandFunction</td>          <td class="paramname"><span class="paramname"><em>cmdfunc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a command from the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the command </td></tr>
    <tr><td class="paramname">handle</td><td>The new object that will handle the command </td></tr>
    <tr><td class="paramname">cmdfunc</td><td>The new function pointer of the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the command was replaced, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="a5392ac40d7e1aac17ded713661250303" name="a5392ac40d7e1aac17ded713661250303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5392ac40d7e1aac17ded713661250303">&#9670;&#160;</a></span>saveCustomData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fge::Scene::saveCustomData </td>
          <td>(</td>
          <td class="paramtype">nlohmann::json &amp;</td>          <td class="paramname"><span class="paramname"><em>jsonObject</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save some user defined custom data. </p>
<p>This function doesn't do anything by default but can be override to save some data during a saveInFile call.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6edde93a552e2e2d449596331f8d728" title="Save all the Scene with its Object in a file.">saveInFile</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonObject</td><td>The json object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6edde93a552e2e2d449596331f8d728" name="ae6edde93a552e2e2d449596331f8d728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6edde93a552e2e2d449596331f8d728">&#9670;&#160;</a></span>saveInFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::saveInFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save all the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> with its <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in a file. </p>
<p>This function save all the data in a json format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2355bd9912b4ed5b1fd7707a046cfcea" title="Load all the Scene data from a json file.">loadFromFile</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if successful, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="a9f910bebd40741e4714be2e54cf98f11" name="a9f910bebd40741e4714be2e54cf98f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f910bebd40741e4714be2e54cf98f11">&#9670;&#160;</a></span>setCallbackContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::setCallbackContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfge_1_1CallbackContext.html">fge::CallbackContext</a></td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback context of this <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>By setting a callback context, the scene will be able to automatically call <a class="el" href="classfge_1_1Object.html#ae9f531a05d43d09501849905d1e2f00c" title="Ask the object to register all callbacks it needs to receive events.">Object::callbackRegister</a> during object creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The callback context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad802b973a26fb69a7925ec0fb1b0b62c" name="ad802b973a26fb69a7925ec0fb1b0b62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad802b973a26fb69a7925ec0fb1b0b62c">&#9670;&#160;</a></span>setCustomView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::setCustomView </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classfge_1_1View.html">fge::View</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>customView</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom shared view. </p>
<p>This is useful if you need to draw a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> in another place in the screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customView</td><td>The shared pointer of a view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a951584bafb9b1bc616e0377209ef5317" name="a951584bafb9b1bc616e0377209ef5317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951584bafb9b1bc616e0377209ef5317">&#9670;&#160;</a></span>setLinkedRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::setLinkedRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> to the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This is useful for any <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> that required an <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> in its method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classfge_1_1RenderTarget.html">RenderTarget</a> (can be <b>nullptr</b>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12af96b94b0e41650589ba79514c134f" name="a12af96b94b0e41650589ba79514c134f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12af96b94b0e41650589ba79514c134f">&#9670;&#160;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::setName </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name of the scene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531e9afb32984550bc6b0690029f8125" name="a531e9afb32984550bc6b0690029f8125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531e9afb32984550bc6b0690029f8125">&#9670;&#160;</a></span>setObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::setObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectPtr &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>newObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer in place of the provided one. </p>
<dl class="section warning"><dt>Warning</dt><dd>The provided pointer must respect the same rule as a newly created object with the <a class="el" href="#a9ccfa1288c2909a7b1e9bea3c4ae12cd" title="Add a new Object in the Scene.">newObject()</a> method</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
    <tr><td class="paramname">newObject</td><td>The new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the change is successful </dd></dl>

</div>
</div>
<a id="ad98f474bb0c8a7ad623cd01a928aaf02" name="ad98f474bb0c8a7ad623cd01a928aaf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98f474bb0c8a7ad623cd01a928aaf02">&#9670;&#160;</a></span>setObjectPlan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::setObjectPlan </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectPlan</td>          <td class="paramname"><span class="paramname"><em>newPlan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> plan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
    <tr><td class="paramname">newPlan</td><td>The new plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the change is successful </dd></dl>

</div>
</div>
<a id="adcc04cfdb2202e64dc16b5576a87e661" name="adcc04cfdb2202e64dc16b5576a87e661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc04cfdb2202e64dc16b5576a87e661">&#9670;&#160;</a></span>setObjectPlanBot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::setObjectPlanBot </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the bottom of his plan. </p>
<p>This make the object be drawn last.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the change is successful </dd></dl>

</div>
</div>
<a id="a9dc5619ea7889f3108eb341b3fbc9f84" name="a9dc5619ea7889f3108eb341b3fbc9f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc5619ea7889f3108eb341b3fbc9f84">&#9670;&#160;</a></span>setObjectPlanTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::setObjectPlanTop </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> on top of his plan. </p>
<p>This make the object be drawn first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the change is successful </dd></dl>

</div>
</div>
<a id="a9b04bf715eec7bb77466df34b117ad01" name="a9b04bf715eec7bb77466df34b117ad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b04bf715eec7bb77466df34b117ad01">&#9670;&#160;</a></span>setObjectSid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fge::Scene::setObjectSid </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>newSid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with a new SID. </p>
<p>If the new SID is FGE_SCENE_BAD_SID, the method return <b>false</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>Actual SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
    <tr><td class="paramname">newSid</td><td>The new SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the change is successful </dd></dl>

</div>
</div>
<a id="a75d177f7c0ddb45997668532f91fc1b4" name="a75d177f7c0ddb45997668532f91fc1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d177f7c0ddb45997668532f91fc1b4">&#9670;&#160;</a></span>transferObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectDataShared fge::Scene::transferObject </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Scene.html">fge::Scene</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newScene</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer the specified <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to another <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>The provided <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> must not have another <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> with the same SID, causing the method to failed and return an invalid shared pointer.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is not meant to be used on the same <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>, however it will work as expected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The SID of the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> to be transferred </td></tr>
    <tr><td class="paramname">newScene</td><td>The <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> that will get the <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An shared pointer of the transferred <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> from the new scene </dd></dl>

</div>
</div>
<a id="a679edf7567a83d8008482aa777e2ab8d" name="a679edf7567a83d8008482aa777e2ab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679edf7567a83d8008482aa777e2ab8d">&#9670;&#160;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt; fge::Scene::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack all the received data of a serverside <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This function delete every actual <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> except GUI <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a76a9e75a5e156fe96f28e3180f3cff7d" title="Pack all the Scene data in a Packet.">pack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad32308d155bf1be24e982d4ea5bc16b7" name="ad32308d155bf1be24e982d4ea5bc16b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32308d155bf1be24e982d4ea5bc16b7">&#9670;&#160;</a></span>unpackModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt; fge::Scene::unpackModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1UpdateCountRange.html">UpdateCountRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>updateCountRange</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isPreExtractedPacket</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack all modification of received data packet from a server. </p>
<p>This function only extract <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> partial data, for full <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> sync please see pack and unpack.</p>
<p>Packets can arrive in any order, so this function will check if the packet continuity is respected. When returning an net::Error::ERR_SCENE_NEED_CACHING, use should stop extraction and push the received packet into a <a class="el" href="classfge_1_1SceneUpdateCache.html" title="A cache for scene updates.">SceneUpdateCache</a> class.</p>
<p>The packet after returning an net::Error::ERR_SCENE_NEED_CACHING is considered pre-extracted and the next time you call this function, you have to set the isPreExtractedPacket argument to <b>true</b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7c93e6fbc04ac4be98bb7951e06760f1" title="Pack all modification in a net::Packet for a net::Client.">packModification</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
    <tr><td class="paramname">updateCountRange</td><td>A reference that will be used to extract update count range </td></tr>
    <tr><td class="paramname">isPreExtractedPacket</td><td>If <b>true</b>, the packet has already pre-extracted and is coming from a cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1cac81955acf6a681d3ae4c125b8245" name="ab1cac81955acf6a681d3ae4c125b8245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cac81955acf6a681d3ae4c125b8245">&#9670;&#160;</a></span>unpackNeededUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt; fge::Scene::unpackNeededUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfge_1_1net_1_1Identity.html">fge::net::Identity</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack client object that require an explicit update. </p>
<p>This should be called by a server.</p>
<dl class="section see"><dt>See also</dt><dd>NetworkTypeContainer::packNeededUpdate</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
    <tr><td class="paramname">id</td><td>The Identity of the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6329737994a6c1e7d33877398a98556" name="ae6329737994a6c1e7d33877398a98556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6329737994a6c1e7d33877398a98556">&#9670;&#160;</a></span>unpackWatchedEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structfge_1_1net_1_1Error.html">fge::net::Error</a> &gt; fge::Scene::unpackWatchedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1net_1_1Packet.html">fge::net::Packet</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>pck</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack all <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related events from a server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pck</td><td>The network packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1bca7b135815669dba730aab11f61d" name="a4b1bca7b135815669dba730aab11f61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1bca7b135815669dba730aab11f61d">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfge_1_1RenderWindow.html">fge::RenderWindow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>screen</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfge_1_1Event.html">fge::Event</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds const &amp;</td>          <td class="paramname"><span class="paramname"><em>deltaTime</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::underlying_type_t&lt; UpdateFlags &gt;</td>          <td class="paramname"><span class="paramname"><em>flags</em><span class="paramdefsep"> = </span><span class="paramdefval">UpdateFlags::NONE</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update of the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. </p>
<p>This method call the <a class="el" href="classfge_1_1Object.html#ac721a6ca8d50e47955f41252f18da533" title="Main method called every frame.">Object::update</a> method of every <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> in the scene.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the updated <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> want to delete itself during an update, it have to use the delUpdatedObject and not any others delete methode that will cause undefined behaviour.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screen</td><td>A <a class="el" href="classfge_1_1RenderWindow.html">RenderWindow</a> </td></tr>
    <tr><td class="paramname">event</td><td>The FastEngine <a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> class </td></tr>
    <tr><td class="paramname">deltaTime</td><td>The time in microseconds between two updates </td></tr>
    <tr><td class="paramname">flags</td><td>Some flags to control the update like the update count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a251b5846d699bf47b1f4304b9108663c" name="a251b5846d699bf47b1f4304b9108663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251b5846d699bf47b1f4304b9108663c">&#9670;&#160;</a></span>updateAllPlanDepth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::updateAllPlanDepth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the ObjectPlanDepth for every objects </p>
<p>This method should not really be used as the depth is automatically calculated inside the draw method. </p>

</div>
</div>
<a id="a15d58a5aeb3cf0bb800203cc9421d9b2" name="a15d58a5aeb3cf0bb800203cc9421d9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d58a5aeb3cf0bb800203cc9421d9b2">&#9670;&#160;</a></span>updateAllPlanDepth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::updateAllPlanDepth </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectPlan</td>          <td class="paramname"><span class="paramname"><em>plan</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the ObjectPlanDepth for every objects inside the same plan </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>The plan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6ecef294e7c2f0bd21f6c8a278d6d87" name="ab6ecef294e7c2f0bd21f6c8a278d6d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ecef294e7c2f0bd21f6c8a278d6d87">&#9670;&#160;</a></span>updatePlanDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fge::ObjectPlanDepth fge::Scene::updatePlanDepth </td>
          <td>(</td>
          <td class="paramtype">fge::ObjectSid</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the ObjectPlanDepth for one object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The object sid the will be updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new ObjectPlanDepth </dd></dl>

</div>
</div>
<a id="ae238766ad9a6fddfcec948bfe3d1e2e1" name="ae238766ad9a6fddfcec948bfe3d1e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae238766ad9a6fddfcec948bfe3d1e2e1">&#9670;&#160;</a></span>watchEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fge::Scene::watchEvent </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start to watch <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related event or not. </p>
<p>When <b>true</b>, the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> will start to push <a class="el" href="structfge_1_1SceneNetEvent.html" title="Structure that represent an network event related to Scene.">SceneNetEvent</a> for clients. This is <b>false</b> by default to avoid events overflow.</p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structfge_1_1SceneNetEvent.html" title="Structure that represent an network event related to Scene.">SceneNetEvent</a> have to be cleared manually by the user with deleteEvents.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on</td><td>Start or stop watching <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> related events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad08489fa18d103b308c7b33a992e639a" name="ad08489fa18d103b308c7b33a992e639a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08489fa18d103b308c7b33a992e639a">&#9670;&#160;</a></span>_netList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1net_1_1NetworkTypeContainer.html">fge::net::NetworkTypeContainer</a> fge::Scene::_netList</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The network list must be used to synchronised data between client and server. </p>

</div>
</div>
<a id="a3607c8eb643375226efb428857d9f272" name="a3607c8eb643375226efb428857d9f272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3607c8eb643375226efb428857d9f272">&#9670;&#160;</a></span>_onDelayedUpdate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt;<a class="el" href="classfge_1_1Scene.html">fge::Scene</a>*&gt; fge::Scene::_onDelayedUpdate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called only once after a <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> update. </p>
<p>You or an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> can register a one time callback that will be called after updating the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a>. Once called, callbacks is cleared. </p>

</div>
</div>
<a id="a4ef1b051a388cb1e614493140d546f8b" name="a4ef1b051a388cb1e614493140d546f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef1b051a388cb1e614493140d546f8b">&#9670;&#160;</a></span>_onDraw</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt;<a class="el" href="classfge_1_1Scene.html">fge::Scene</a> const*, <a class="el" href="classfge_1_1RenderTarget.html">fge::RenderTarget</a>&amp;&gt; fge::Scene::_onDraw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when the <a class="el" href="classfge_1_1Scene.html" title="A scene contain a collection of object and handle them.">Scene</a> is about to be drawn. </p>

</div>
</div>
<a id="afc54dec6f8b659e284c76423707bb95b" name="afc54dec6f8b659e284c76423707bb95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54dec6f8b659e284c76423707bb95b">&#9670;&#160;</a></span>_onObjectAdded</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt;<a class="el" href="classfge_1_1Scene.html">fge::Scene</a>*, fge::ObjectDataShared const&amp;&gt; fge::Scene::_onObjectAdded</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when a new <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> has been added. </p>

</div>
</div>
<a id="ad94e57f18a5e1f606a69a9a8931f7250" name="ad94e57f18a5e1f606a69a9a8931f7250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e57f18a5e1f606a69a9a8931f7250">&#9670;&#160;</a></span>_onObjectRemoved</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt;<a class="el" href="classfge_1_1Scene.html">fge::Scene</a>*, fge::ObjectDataShared const&amp;&gt; fge::Scene::_onObjectRemoved</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> has been removed. </p>

</div>
</div>
<a id="a37ac8e8febbbde5ca7778a39edfa9848" name="a37ac8e8febbbde5ca7778a39edfa9848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ac8e8febbbde5ca7778a39edfa9848">&#9670;&#160;</a></span>_onPlanUpdate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1CallbackHandler.html">fge::CallbackHandler</a>&lt;<a class="el" href="classfge_1_1Scene.html">fge::Scene</a>*, fge::ObjectPlan&gt; fge::Scene::_onPlanUpdate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classfge_1_1Event.html" title="This class is a wrapper for SDL events.">Event</a> called when a change in the plan is detected. </p>
<p>When an <a class="el" href="classfge_1_1Object.html" title="The Object class is the base class for all objects in the engine.">Object</a> change his plan, is created, is deleted ... this event is called. The ObjectPlan argument can be FGE_SCENE_BAD_PLAN, this mean that all plans have been impacted. </p>

</div>
</div>
<a id="aa60918f884f77c90d94064d2638b676c" name="aa60918f884f77c90d94064d2638b676c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60918f884f77c90d94064d2638b676c">&#9670;&#160;</a></span>_properties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfge_1_1PropertyList.html">fge::PropertyList</a> fge::Scene::_properties</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The properties list is a multi-type container for multi-purpose use. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="C__scene_8hpp_source.html">C_scene.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
